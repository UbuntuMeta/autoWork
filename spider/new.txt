

程序能一次写完并正常运行的概率很小，基本不超过1%。总会有各种各样的bug需要修正。有的bug很简单，看看错误信息就知道，有的bug很复杂，我们需要知道出错时，哪些变量的值是正确的，哪些变量的值是错误的，因此，需要一整套调试程序的手段来修复bug。

第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看：
def foo(s):
    n = int(s)
    print('&gt;&gt;&gt; n = %d' % n)
    return 10 / n

def main():
    foo('0')

main()


执行后在输出中查找打印的变量值：
$ python3 err.py
&gt;&gt;&gt; n = 0
Traceback (most recent call last):
  ...
ZeroDivisionError: integer division or modulo by zero


用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。所以，我们又有第二种方法。

断言

凡是用print()来辅助查看的地方，都可以用断言（assert）来替代：
def foo(s):
    n = int(s)
    assert n != 0, 'n is zero!'
    return 10 / n

def main():
    foo('0')


assert的意思是，表达式n
 != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错。

如果断言失败，assert语句本身就会抛出AssertionError：
$ python3 err.py
Traceback (most recent call last):
  ...
AssertionError: n is zero!


程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert：
$ python3 -O err.py
Traceback (most recent call last):
  ...
ZeroDivisionError: division by zero


关闭后，你可以把所有的assert语句当成pass来看。

logging

把print()替换为logging是第3种方式，和assert比，logging不会抛出错误，而且可以输出到文件：
import logging

s = '0'
n = int(s)
logging.info('n = %d' % n)
print(10 / n)


logging.info()就可以输出一段文本。运行，发现除了ZeroDivisionError，没有任何信息。怎么回事？

别急，在import logging之后添加一行配置再试试：
import logging
logging.basicConfig(level=logging.INFO)


看到输出了：
$ python3 err.py
INFO:root:n = 0
Traceback (most recent call last):
  File "err.py", line 8, in &lt;module&gt;
    print(10 / n)
ZeroDivisionError: division by zero


这就是logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。

logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。

pdb

第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：
# err.py
s = '0'
n = int(s)
print(10 / n)


然后启动：
$ python3 -m pdb err.py
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()
-&gt; s = '0'


以参数-m pdb启动后，pdb定位到下一步要执行的代码-&gt;
 s = '0'。输入命令l来查看代码：
(Pdb) l
  1     # err.py
  2  -&gt; s = '0'
  3     n = int(s)
  4     print(10 / n)


输入命令n可以单步执行代码：
(Pdb) n
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(3)&lt;module&gt;()
-&gt; n = int(s)
(Pdb) n
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(4)&lt;module&gt;()
-&gt; print(10 / n)


任何时候都可以输入命令p 变量名来查看变量：
(Pdb) p s
'0'
(Pdb) p n
0


输入命令q结束调试，退出程序：
(Pdb) q


这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令啊。还好，我们还有另一种调试方法。

pdb.set_trace()

这个方法也是用pdb，但是不需要单步执行，我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点：
# err.py
import pdb

s = '0'
n = int(s)
pdb.set_trace() # 运行到这里会自动暂停
print(10 / n)


运行代码，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行：
$ python3 err.py 
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(7)&lt;module&gt;()
-&gt; print(10 / n)
(Pdb) p n
0
(Pdb) c
Traceback (most recent call last):
  File "err.py", line 7, in &lt;module&gt;
    print(10 / n)
ZeroDivisionError: division by zero


这个方式比直接启动pdb单步调试效率要高很多，但也高不到哪去。

IDE

如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的IDE。目前比较好的Python IDE有PyCharm：

http://www.jetbrains.com/pycharm/

另外，Eclipse加上pydev插件也可以调试Python程序。

小结

写程序最痛苦的事情莫过于调试，程序往往会以你意想不到的流程来运行，你期待执行的语句其实根本没有执行，这时候，就需要调试了。

虽然用IDE调试起来比较方便，但是最后你会发现，logging才是终极武器。


在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数open()，成功时返回文件描述符（就是一个整数），出错时返回-1。

用错误码来表示是否出错十分不便，因为函数本身应该返回的正常结果和错误码混在一起，造成调用者必须用大量的代码来判断是否出错：
def foo():
    r = some_function()
    if r==(-1):
        return (-1)
    # do something
    return r

def bar():
    r = foo()
    if r==(-1):
        print('Error')
    else:
        pass


一旦出错，还要一级一级上报，直到某个函数可以处理该错误（比如，给用户输出一个错误信息）。

所以高级语言通常都内置了一套try...except...finally...的错误处理机制，Python也不例外。

try

让我们用一个例子来看看try的机制：
try:
    print('try...')
    r = 10 / 0
    print('result:', r)
except ZeroDivisionError as e:
    print('except:', e)
finally:
    print('finally...')
print('END')


当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。

上面的代码在计算10 / 0时会产生一个除法运算错误：
try...
except: division by zero
finally...
END


从输出可以看到，当错误发生时，后续语句print('result:', r)不会被执行，except由于捕获到ZeroDivisionError，因此被执行。最后，finally语句被执行。然后，程序继续按照流程往下走。

如果把除数0改成2，则执行结果如下：
try...
result: 5
finally...
END


由于没有错误发生，所以except语句块不会被执行，但是finally如果有，则一定会被执行（可以没有finally语句）。

你还可以猜测，错误应该有很多种类，如果发生了不同类型的错误，应该由不同的except语句块处理。没错，可以有多个except来捕获不同类型的错误：
try:
    print('try...')
    r = 10 / int('a')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
finally:
    print('finally...')
print('END')


int()函数可能会抛出ValueError，所以我们用一个except捕获ValueError，用另一个except捕获ZeroDivisionError。

此外，如果没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句：
try:
    print('try...')
    r = 10 / int('2')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
else:
    print('no error!')
finally:
    print('finally...')
print('END')


Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：
try:
    foo()
except ValueError as e:
    print('ValueError')
except UnicodeError as e:
    print('UnicodeError')


第二个except永远也捕获不到UnicodeError，因为UnicodeError是ValueError的子类，如果有，也被第一个except给捕获了。

Python所有的错误都是从BaseException类派生的，常见的错误类型和继承关系看这里：

https://docs.python.org/3/library/exceptions.html#exception-hierarchy

使用try...except捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用foo()，foo()调用bar()，结果bar()出错了，这时，只要main()捕获到了，就可以处理：
def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        print('Error:', e)
    finally:
        print('finally...')


也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写try...except...finally的麻烦。

调用堆栈

如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。来看看err.py：
# err.py:
def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    bar('0')

main()


执行，结果如下：
$ python3 err.py
Traceback (most recent call last):
  File "err.py", line 11, in &lt;module&gt;
    main()
  File "err.py", line 9, in main
    bar('0')
  File "err.py", line 6, in bar
    return foo(s) * 2
  File "err.py", line 3, in foo
    return 10 / int(s)
ZeroDivisionError: division by zero


出错并不可怕，可怕的是不知道哪里出错了。解读错误信息是定位错误的关键。我们从上往下可以看到整个错误的调用函数链：

错误信息第1行：
Traceback (most recent call last):


告诉我们这是错误的跟踪信息。

第2~3行：
  File "err.py", line 11, in &lt;module&gt;
    main()


调用main()出错了，在代码文件err.py的第11行代码，但原因是第9行：
  File "err.py", line 9, in main
    bar('0')


调用bar('0')出错了，在代码文件err.py的第9行代码，但原因是第6行：
  File "err.py", line 6, in bar
    return foo(s) * 2


原因是return foo(s) * 2这个语句出错了，但这还不是最终原因，继续往下看：
  File "err.py", line 3, in foo
    return 10 / int(s)


原因是return 10 / int(s)这个语句出错了，这是错误产生的源头，因为下面打印了：
ZeroDivisionError: integer division or modulo by zero


根据错误类型ZeroDivisionError，我们判断，int(s)本身并没有出错，但是int(s)返回0，在计算10
 / 0时出错，至此，找到错误源头。

记录错误

如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。

Python内置的logging模块可以非常容易地记录错误信息：
# err_logging.py

import logging

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        logging.exception(e)

main()
print('END')


同样是出错，但程序打印完错误信息后会继续执行，并正常退出：
$ python3 err_logging.py
ERROR:root:division by zero
Traceback (most recent call last):
  File "err_logging.py", line 13, in main
    bar('0')
  File "err_logging.py", line 9, in bar
    return foo(s) * 2
  File "err_logging.py", line 6, in foo
    return 10 / int(s)
ZeroDivisionError: division by zero
END


通过配置，logging还可以把错误记录到日志文件里，方便事后排查。

抛出错误

因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。

如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用raise语句抛出一个错误的实例：
# err_raise.py
class FooError(ValueError):
    pass

def foo(s):
    n = int(s)
    if n==0:
        raise FooError('invalid value: %s' % s)
    return 10 / n

foo('0')


执行，可以最后跟踪到我们自己定义的错误：
$ python3 err_raise.py 
Traceback (most recent call last):
  File "err_throw.py", line 11, in &lt;module&gt;
    foo('0')
  File "err_throw.py", line 8, in foo
    raise FooError('invalid value: %s' % s)
__main__.FooError: invalid value: 0


只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。

最后，我们来看另一种错误处理的方式：
# err_reraise.py

def foo(s):
    n = int(s)
    if n==0:
        raise ValueError('invalid value: %s' % s)
    return 10 / n

def bar():
    try:
        foo('0')
    except ValueError as e:
        print('ValueError!')
        raise

bar()


在bar()函数中，我们明明已经捕获了错误，但是，打印一个ValueError!后，又把错误通过raise语句抛出去了，这不有病么？

其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终会抛给CEO去处理。

raise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型：
try:
    10 / 0
except ZeroDivisionError:
    raise ValueError('input error!')


只要是合理的转换逻辑就可以，但是，决不应该把一个IOError转换成毫不相干的ValueError。

小结

Python内置的try...except...finally用来处理错误十分方便。出错时，会分析错误信息并定位错误发生的代码位置才是最关键的。

程序也可以主动抛出错误，让调用者来处理相应的错误。但是，应该在文档中写清楚可能会抛出哪些错误，以及错误产生的原因。


type()

动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。

比方说我们要定义一个Hello的class，就写一个hello.py模块：
class Hello(object):
    def hello(self, name='world'):
        print('Hello, %s.' % name)


当Python解释器载入hello模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个Hello的class对象，测试如下：
&gt;&gt;&gt; from hello import Hello
&gt;&gt;&gt; h = Hello()
&gt;&gt;&gt; h.hello()
Hello, world.
&gt;&gt;&gt; print(type(Hello))
&lt;class 'type'&gt;
&gt;&gt;&gt; print(type(h))
&lt;class 'hello.Hello'&gt;


type()函数可以查看一个类型或变量的类型，Hello是一个class，它的类型就是type，而h是一个实例，它的类型就是class

Hello。

我们说class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。

type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建出Hello类，而无需通过class
 Hello(object)...的定义：
&gt;&gt;&gt; def fn(self, name='world'): # 先定义函数
...     print('Hello, %s.' % name)
...
&gt;&gt;&gt; Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
&gt;&gt;&gt; h = Hello()
&gt;&gt;&gt; h.hello()
Hello, world.
&gt;&gt;&gt; print(type(Hello))
&lt;class 'type'&gt;
&gt;&gt;&gt; print(type(h))
&lt;class '__main__.Hello'&gt;


要创建一个class对象，type()函数依次传入3个参数：

class的名称；继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。

通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。

正常情况下，我们都用class Xxx...来定义类，但是，type()函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。

metaclass

除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass。

metaclass，直译为元类，简单的解释就是：

当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。

但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。

连接起来就是：先定义metaclass，就可以创建类，最后创建实例。

所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。

metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。

我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法：

定义ListMetaclass，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：
# metaclass是类的模板，所以必须从`type`类型派生：
class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs['add'] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)


有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass：
class MyList(list, metaclass=ListMetaclass):
    pass


当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在创建MyList时，要通过ListMetaclass.__new__()来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。

__new__()方法接收到的参数依次是：



当前准备创建的类的对象；


类的名字；


类继承的父类集合；


类的方法集合。


测试一下MyList是否可以调用add()方法：
&gt;&gt;&gt; L = MyList()
&gt;&gt;&gt; L.add(1)
&gt;&gt; L
[1]


而普通的list没有add()方法：
&gt;&gt;&gt; L2 = list()
&gt;&gt;&gt; L2.add(1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'list' object has no attribute 'add'


动态修改有什么意义？直接在MyList定义中写上add()方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。

但是，总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子。

ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。

要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。

让我们来尝试编写一个ORM框架。

编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个User类来操作对应的数据库表User，我们期待他写出这样的代码：
class User(Model):
    # 定义类的属性到列的映射：
    id = IntegerField('id')
    name = StringField('username')
    email = StringField('email')
    password = StringField('password')

# 创建一个实例：
u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')
# 保存到数据库：
u.save()


其中，父类Model和属性类型StringField、IntegerField是由ORM框架提供的，剩下的魔术方法比如save()全部由metaclass自动完成。虽然metaclass的编写会比较复杂，但ORM的使用者用起来却异常简单。

现在，我们就按上面的接口来实现该ORM。

首先来定义Field类，它负责保存数据库表的字段名和字段类型：
class Field(object):

    def __init__(self, name, column_type):
        self.name = name
        self.column_type = column_type

    def __str__(self):
        return '&lt;%s:%s&gt;' % (self.__class__.__name__, self.name)


在Field的基础上，进一步定义各种类型的Field，比如StringField，IntegerField等等：
class StringField(Field):

    def __init__(self, name):
        super(StringField, self).__init__(name, 'varchar(100)')

class IntegerField(Field):

    def __init__(self, name):
        super(IntegerField, self).__init__(name, 'bigint')


下一步，就是编写最复杂的ModelMetaclass了：
class ModelMetaclass(type):

    def __new__(cls, name, bases, attrs):
        if name=='Model':
            return type.__new__(cls, name, bases, attrs)
        print('Found model: %s' % name)
        mappings = dict()
        for k, v in attrs.items():
            if isinstance(v, Field):
                print('Found mapping: %s ==&gt; %s' % (k, v))
                mappings[k] = v
        for k in mappings.keys():
            attrs.pop(k)
        attrs['__mappings__'] = mappings # 保存属性和列的映射关系
        attrs['__table__'] = name # 假设表名和类名一致
        return type.__new__(cls, name, bases, attrs)


以及基类Model：
class Model(dict, metaclass=ModelMetaclass):

    def __init__(self, **kw):
        super(Model, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r"'Model' object has no attribute '%s'" % key)

    def __setattr__(self, key, value):
        self[key] = value

    def save(self):
        fields = []
        params = []
        args = []
        for k, v in self.__mappings__.items():
            fields.append(v.name)
            params.append('?')
            args.append(getattr(self, k, None))
        sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(params))
        print('SQL: %s' % sql)
        print('ARGS: %s' % str(args))


当用户定义一个class User(Model)时，Python解释器首先在当前类User的定义中查找metaclass，如果没有找到，就继续在父类Model中查找metaclass，找到了，就使用Model中定义的metaclass的ModelMetaclass来创建User类，也就是说，metaclass可以隐式地继承到子类，但子类自己却感觉不到。

在ModelMetaclass中，一共做了几件事情：



排除掉对Model类的修改；


在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个__mappings__的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误（实例的属性会遮盖类的同名属性）；


把表名保存到__table__中，这里简化为表名默认为类名。


在Model类中，就可以定义各种操作数据库的方法，比如save()，delete()，find()，update等等。

我们实现了save()方法，把一个实例保存到数据库中。因为有表名，属性到字段的映射和属性值的集合，就可以构造出INSERT语句。

编写代码试试：
u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')
u.save()


输出如下：
Found model: User
Found mapping: email ==&gt; &lt;StringField:email&gt;
Found mapping: password ==&gt; &lt;StringField:password&gt;
Found mapping: id ==&gt; &lt;IntegerField:uid&gt;
Found mapping: name ==&gt; &lt;StringField:username&gt;
SQL: insert into User (password,email,username,id) values (?,?,?,?)
ARGS: ['my-pwd', 'test@orm.org', 'Michael', 12345]


可以看到，save()方法已经打印出了可执行的SQL语句，以及参数列表，只需要真正连接到数据库，执行该SQL语句，就可以完成真正的功能。

不到100行代码，我们就通过metaclass实现了一个精简的ORM框架。

小结

metaclass是Python中非常具有魔术性的对象，它可以改变类创建时的行为。这种强大的功能使用起来务必小心。


当我们需要定义常量时，一个办法是用大写变量通过整数来定义，例如月份：
JAN = 1
FEB = 2
MAR = 3
...
NOV = 11
DEC = 12


好处是简单，缺点是类型是int，并且仍然是变量。

更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能：
from enum import Enum

Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))


这样我们就获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员：
for name, member in Month.__members__.items():
    print(name, '=&gt;', member, ',', member.value)


value属性则是自动赋给成员的int常量，默认从1开始计数。

如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：
from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6


@unique装饰器可以帮助我们检查保证没有重复值。

访问这些枚举类型可以有若干种方法：
&gt;&gt;&gt; day1 = Weekday.Mon
&gt;&gt;&gt; print(day1)
Weekday.Mon
&gt;&gt;&gt; print(Weekday.Tue)
Weekday.Tue
&gt;&gt;&gt; print(Weekday['Tue'])
Weekday.Tue
&gt;&gt;&gt; print(Weekday.Tue.value)
2
&gt;&gt;&gt; print(day1 == Weekday.Mon)
True
&gt;&gt;&gt; print(day1 == Weekday.Tue)
False
&gt;&gt;&gt; print(Weekday(1))
Weekday.Mon
&gt;&gt;&gt; print(day1 == Weekday(1))
True
&gt;&gt;&gt; Weekday(7)
Traceback (most recent call last):
  ...
ValueError: 7 is not a valid Weekday
&gt;&gt;&gt; for name, member in Weekday.__members__.items():
...     print(name, '=&gt;', member)
...
Sun =&gt; Weekday.Sun
Mon =&gt; Weekday.Mon
Tue =&gt; Weekday.Tue
Wed =&gt; Weekday.Wed
Thu =&gt; Weekday.Thu
Fri =&gt; Weekday.Fri
Sat =&gt; Weekday.Sat


可见，既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。

小结

Enum可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。


看到类似__slots__这种形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的。

__slots__我们已经知道怎么用了，__len__()方法我们也知道是为了能让class作用于len()函数。

除此之外，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。

__str__

我们先定义一个Student类，打印一个实例：
&gt;&gt;&gt; class Student(object):
...     def __init__(self, name):
...         self.name = name
...
&gt;&gt;&gt; print(Student('Michael'))
&lt;__main__.Student object at 0x109afb190&gt;


打印出一堆&lt;__main__.Student object at 0x109afb190&gt;，不好看。

怎么才能打印得好看呢？只需要定义好__str__()方法，返回一个好看的字符串就可以了：
&gt;&gt;&gt; class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def __str__(self):
...         return 'Student object (name: %s)' % self.name
...
&gt;&gt;&gt; print(Student('Michael'))
Student object (name: Michael)


这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。

但是细心的朋友会发现直接敲变量不用print，打印出来的实例还是不好看：
&gt;&gt;&gt; s = Student('Michael')
&gt;&gt;&gt; s
&lt;__main__.Student object at 0x109afb310&gt;


这是因为直接显示变量调用的不是__str__()，而是__repr__()，两者的区别是__str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的。

解决办法是再定义一个__repr__()。但是通常__str__()和__repr__()代码都是一样的，所以，有个偷懒的写法：
class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name=%s)' % self.name
    __repr__ = __str__


__iter__

如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。

我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &gt; 100000: # 退出循环的条件
            raise StopIteration();
        return self.a # 返回下一个值


现在，试试把Fib实例作用于for循环：
&gt;&gt;&gt; for n in Fib():
...     print(n)
...
1
1
2
3
5
...
46368
75025


__getitem__

Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：
&gt;&gt;&gt; Fib()[5]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'Fib' object does not support indexing


要表现得像list那样按照下标取出元素，需要实现__getitem__()方法：
class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a


现在，就可以按下标访问数列的任意一项了：
&gt;&gt;&gt; f = Fib()
&gt;&gt;&gt; f[0]
1
&gt;&gt;&gt; f[1]
1
&gt;&gt;&gt; f[2]
2
&gt;&gt;&gt; f[3]
3
&gt;&gt;&gt; f[10]
89
&gt;&gt;&gt; f[100]
573147844013817084101


但是list有个神奇的切片方法：
&gt;&gt;&gt; list(range(100))[5:10]
[5, 6, 7, 8, 9]


对于Fib却报错。原因是__getitem__()传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断：
class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L


现在试试Fib的切片：
&gt;&gt;&gt; f = Fib()
&gt;&gt;&gt; f[0:5]
[1, 1, 2, 3, 5]
&gt;&gt;&gt; f[:10]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]


但是没有对step参数作处理：
&gt;&gt;&gt; f[:10:2]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]


也没有对负数作处理，所以，要正确实现一个__getitem__()还是有很多工作要做的。

此外，如果把对象看成dict，__getitem__()的参数也可能是一个可以作key的object，例如str。

与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。

总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。

__getattr__

正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：
class Student(object):

    def __init__(self):
        self.name = 'Michael'


调用name属性，没问题，但是，调用不存在的score属性，就有问题了：
&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; print(s.name)
Michael
&gt;&gt;&gt; print(s.score)
Traceback (most recent call last):
  ...
AttributeError: 'Student' object has no attribute 'score'


错误信息很清楚地告诉我们，没有找到score这个attribute。

要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个__getattr__()方法，动态返回一个属性。修改如下：
class Student(object):

    def __init__(self):
        self.name = 'Michael'

    def __getattr__(self, attr):
        if attr=='score':
            return 99


当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__(self,
 'score')来尝试获得属性，这样，我们就有机会返回score的值：
&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.name
'Michael'
&gt;&gt;&gt; s.score
99


返回函数也是完全可以的：
class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25


只是调用方式要变为：
&gt;&gt;&gt; s.age()
25


注意，只有在没有找到属性的情况下，才调用__getattr__，已有的属性，比如name，不会在__getattr__中查找。

此外，注意到任意调用如s.abc都会返回None，这是因为我们定义的__getattr__默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误：
class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)


这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。

这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。

举个例子：

现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：

http://api.server/user/friendshttp://api.server/user/timeline/list

如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。

利用完全动态的__getattr__，我们可以写出一个链式调用：
class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__


试试：
&gt;&gt;&gt; Chain().status.user.timeline.list
'/status/user/timeline/list'


这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！

还有些REST API会把参数放到URL中，比如GitHub的API：
GET /users/:user/repos


调用时，需要把:user替换为实际用户名。如果我们能写出这样的链式调用：
Chain().users('michael').repos


就可以非常方便地调用API了。有兴趣的童鞋可以试试写出来。

__call__

一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。能不能直接在实例本身上调用呢？在Python中，答案是肯定的。

任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。请看示例：
class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)


调用方式如下：
&gt;&gt;&gt; s = Student('Michael')
&gt;&gt;&gt; s() # self参数不要传入
My name is Michael.


__call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。

如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。

那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有__call__()的类实例：
&gt;&gt;&gt; callable(Student())
True
&gt;&gt;&gt; callable(max)
True
&gt;&gt;&gt; callable([1, 2, 3])
False
&gt;&gt;&gt; callable(None)
False
&gt;&gt;&gt; callable('str')
False


通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。

小结

Python的class允许定义许多定制方法，可以让我们非常方便地生成特定的类。

本节介绍的是最常用的几个定制方法，还有很多可定制的方法，请参考Python的官方文档。


继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。

回忆一下Animal类层次的设计，假设我们要实现以下4种动物：

Dog - 狗狗；Bat - 蝙蝠；Parrot - 鹦鹉；Ostrich - 鸵鸟。

如果按照哺乳动物和鸟类归类，我们可以设计出这样的类的层次：



但是如果按照“能跑”和“能飞”来归类，我们就应该设计出这样的类的层次：



如果要把上面的两种分类都包含进来，我们就得设计更多的层次：

哺乳类：能跑的哺乳类，能飞的哺乳类；鸟类：能跑的鸟类，能飞的鸟类。

这么一来，类的层次就复杂了：



如果要再增加“宠物类”和“非宠物类”，这么搞下去，类的数量会呈指数增长，很明显这样设计是不行的。

正确的做法是采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：
class Animal(object):
    pass

# 大类:
class Mammal(Animal):
    pass

class Bird(Animal):
    pass

# 各种动物:
class Dog(Mammal):
    pass

class Bat(Mammal):
    pass

class Parrot(Bird):
    pass

class Ostrich(Bird):
    pass


现在，我们要给动物再加上Runnable和Flyable的功能，只需要先定义好Runnable和Flyable的类：
class Runnable(object):
    def run(self):
        print('Running...')

class Flyable(object):
    def fly(self):
        print('Flying...')


对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog：
class Dog(Mammal, Runnable):
    pass


对于需要Flyable功能的动物，就多继承一个Flyable，例如Bat：
class Bat(Mammal, Flyable):
    pass


通过多重继承，一个子类就可以同时获得多个父类的所有功能。

MixIn

在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。

为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：
class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass


MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。

Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。

比如，编写一个多进程模式的TCP服务，定义如下：
class MyTCPServer(TCPServer, ForkingMixIn):
    pass


编写一个多线程模式的UDP服务，定义如下：
class MyUDPServer(UDPServer, ThreadingMixIn):
    pass


如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixIn：
class MyTCPServer(TCPServer, CoroutineMixIn):
    pass


这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。

小结

由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。

只允许单一继承的语言（如Java）不能使用MixIn的设计。


在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：
s = Student()
s.score = 9999


这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：
class Student(object):

    def get_score(self):
         return self._score

    def set_score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value &lt; 0 or value &gt; 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value


现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：
&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.set_score(60) # ok!
&gt;&gt;&gt; s.get_score()
60
&gt;&gt;&gt; s.set_score(9999)
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!


但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。

有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！

还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的：
class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value &lt; 0 or value &gt; 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value


@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：
&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)
&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()
60
&gt;&gt;&gt; s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!


注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。

还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：
class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth


上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。

小结

@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。


正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。先定义class：
class Student(object):
    pass


然后，尝试给实例绑定一个属性：
&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.name = 'Michael' # 动态给实例绑定一个属性
&gt;&gt;&gt; print(s.name)
Michael


还可以尝试给实例绑定一个方法：
&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
&gt;&gt;&gt; from types import MethodType
&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
&gt;&gt;&gt; s.set_age(25) # 调用实例方法
&gt;&gt;&gt; s.age # 测试结果
25


但是，给一个实例绑定的方法，对另一个实例是不起作用的：
&gt;&gt;&gt; s2 = Student() # 创建新的实例
&gt;&gt;&gt; s2.set_age(25) # 尝试调用方法
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'set_age'


为了给所有实例都绑定方法，可以给class绑定方法：
&gt;&gt;&gt; def set_score(self, score):
...     self.score = score
...
&gt;&gt;&gt; Student.set_score = set_score


给class绑定方法后，所有实例均可调用：
&gt;&gt;&gt; s.set_score(100)
&gt;&gt;&gt; s.score
100
&gt;&gt;&gt; s2.set_score(99)
&gt;&gt;&gt; s2.score
99


通常情况下，上面的set_score方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。

使用__slots__

但是，如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。

为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性：
class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称


然后，我们试试：
&gt;&gt;&gt; s = Student() # 创建新的实例
&gt;&gt;&gt; s.name = 'Michael' # 绑定属性'name'
&gt;&gt;&gt; s.age = 25 # 绑定属性'age'
&gt;&gt;&gt; s.score = 99 # 绑定属性'score'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'score'


由于'score'没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。

使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：
&gt;&gt;&gt; class GraduateStudent(Student):
...     pass
...
&gt;&gt;&gt; g = GraduateStudent()
&gt;&gt;&gt; g.score = 9999


除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。


由于Python是动态语言，根据类创建的实例可以任意绑定属性。

给实例绑定属性的方法是通过实例变量，或者通过self变量：
class Student(object):
    def __init__(self, name):
        self.name = name

s = Student('Bob')
s.score = 90


但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：
class Student(object):
    name = 'Student'


当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：
&gt;&gt;&gt; class Student(object):
...     name = 'Student'
...
&gt;&gt;&gt; s = Student() # 创建实例s
&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
&gt;&gt;&gt; print(Student.name) # 打印类的name属性
Student
&gt;&gt;&gt; s.name = 'Michael' # 给实例绑定name属性
&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
&gt;&gt;&gt; del s.name # 如果删除实例的name属性
&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student


从上面的例子可以看出，在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。


当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？

使用type()

首先，我们来判断对象类型，使用type()函数：

基本类型都可以用type()判断：
&gt;&gt;&gt; type(123)
&lt;class 'int'&gt;
&gt;&gt;&gt; type('str')
&lt;class 'str'&gt;
&gt;&gt;&gt; type(None)
&lt;type(None) 'NoneType'&gt;


如果一个变量指向函数或者类，也可以用type()判断：
&gt;&gt;&gt; type(abs)
&lt;class 'builtin_function_or_method'&gt;
&gt;&gt;&gt; type(a)
&lt;class '__main__.Animal'&gt;


但是type()函数返回的是什么类型呢？它返回对应的Class类型。如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同：
&gt;&gt;&gt; type(123)==type(456)
True
&gt;&gt;&gt; type(123)==int
True
&gt;&gt;&gt; type('abc')==type('123')
True
&gt;&gt;&gt; type('abc')==str
True
&gt;&gt;&gt; type('abc')==type(123)
False


判断基本数据类型可以直接写int，str等，但如果要判断一个对象是否是函数怎么办？可以使用types模块中定义的常量：
&gt;&gt;&gt; import types
&gt;&gt;&gt; def fn():
...     pass
...
&gt;&gt;&gt; type(fn)==types.FunctionType
True
&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType
True
&gt;&gt;&gt; type(lambda x: x)==types.LambdaType
True
&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType
True


使用isinstance()

对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。

我们回顾上次的例子，如果继承关系是：
object -&gt; Animal -&gt; Dog -&gt; Husky


那么，isinstance()就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象：
&gt;&gt;&gt; a = Animal()
&gt;&gt;&gt; d = Dog()
&gt;&gt;&gt; h = Husky()


然后，判断：
&gt;&gt;&gt; isinstance(h, Husky)
True


没有问题，因为h变量指向的就是Husky对象。

再判断：
&gt;&gt;&gt; isinstance(h, Dog)
True


h虽然自身是Husky类型，但由于Husky是从Dog继承下来的，所以，h也还是Dog类型。换句话说，isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。

因此，我们可以确信，h还是Animal类型：
&gt;&gt;&gt; isinstance(h, Animal)
True


同理，实际类型是Dog的d也是Animal类型：
&gt;&gt;&gt; isinstance(d, Dog) and isinstance(d, Animal)
True


但是，d不是Husky类型：
&gt;&gt;&gt; isinstance(d, Husky)
False


能用type()判断的基本类型也可以用isinstance()判断：
&gt;&gt;&gt; isinstance('a', str)
True
&gt;&gt;&gt; isinstance(123, int)
True
&gt;&gt;&gt; isinstance(b'a', bytes)
True


并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：
&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))
True
&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))
True


使用dir()

如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：
&gt;&gt;&gt; dir('ABC')
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']


类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的：
&gt;&gt;&gt; len('ABC')
3
&gt;&gt;&gt; 'ABC'.__len__()
3


我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法：
&gt;&gt;&gt; class MyDog(object):
...     def __len__(self):
...         return 100
...
&gt;&gt;&gt; dog = MyDog()
&gt;&gt;&gt; len(dog)
100


剩下的都是普通属性或方法，比如lower()返回小写的字符串：
&gt;&gt;&gt; 'ABC'.lower()
'abc'


仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态：
&gt;&gt;&gt; class MyObject(object):
...     def __init__(self):
...         self.x = 9
...     def power(self):
...         return self.x * self.x
...
&gt;&gt;&gt; obj = MyObject()


紧接着，可以测试该对象的属性：
&gt;&gt;&gt; hasattr(obj, 'x') # 有属性'x'吗？
True
&gt;&gt;&gt; obj.x
9
&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？
False
&gt;&gt;&gt; setattr(obj, 'y', 19) # 设置一个属性'y'
&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？
True
&gt;&gt;&gt; getattr(obj, 'y') # 获取属性'y'
19
&gt;&gt;&gt; obj.y # 获取属性'y'
19


如果试图获取不存在的属性，会抛出AttributeError的错误：
&gt;&gt;&gt; getattr(obj, 'z') # 获取属性'z'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'MyObject' object has no attribute 'z'


可以传入一个default参数，如果属性不存在，就返回默认值：
&gt;&gt;&gt; getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
404


也可以获得对象的方法：
&gt;&gt;&gt; hasattr(obj, 'power') # 有属性'power'吗？
True
&gt;&gt;&gt; getattr(obj, 'power') # 获取属性'power'
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
&gt;&gt;&gt; fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn
&gt;&gt;&gt; fn # fn指向obj.power
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的
81


小结

通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写：
sum = obj.x + obj.y


就不要写：
sum = getattr(obj, 'x') + getattr(obj, 'y')


一个正确的用法的例子如下：
def readImage(fp):
    if hasattr(fp, 'read'):
        return readData(fp)
    return None


假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了用场。

请注意，在Python这类动态语言中，根据鸭子类型，有read()方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要read()方法返回的是有效的图像数据，就不影响读取图像的功能。


在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。

比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：
class Animal(object):
    def run(self):
        print('Animal is running...')


当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：
class Dog(Animal):
    pass

class Cat(Animal):
    pass


对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。

继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：
dog = Dog()
dog.run()

cat = Cat()
cat.run()


运行结果如下：
Animal is running...
Animal is running...


当然，也可以对子类增加一些方法，比如Dog类：
class Dog(Animal):

    def run(self):
        print('Dog is running...')

    def eat(self):
        print('Eating meat...')


继承的第二个好处需要我们对代码做一点改进。你看到了，无论是Dog还是Cat，它们run()的时候，显示的都是Animal
 is running...，符合逻辑的做法是分别显示Dog is running...和Cat
 is running...，因此，对Dog和Cat类改进如下：
class Dog(Animal):

    def run(self):
        print('Dog is running...')

class Cat(Animal):

    def run(self):
        print('Cat is running...')


再次运行，结果如下：
Dog is running...
Cat is running...


当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。

要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：
a = list() # a是list类型
b = Animal() # b是Animal类型
c = Dog() # c是Dog类型


判断一个变量是否是某个类型可以用isinstance()判断：
&gt;&gt;&gt; isinstance(a, list)
True
&gt;&gt;&gt; isinstance(b, Animal)
True
&gt;&gt;&gt; isinstance(c, Dog)
True


看来a、b、c确实对应着list、Animal、Dog这3种类型。

但是等等，试试：
&gt;&gt;&gt; isinstance(c, Animal)
True


看来c不仅仅是Dog，c还是Animal！

不过仔细想想，这是有道理的，因为Dog是从Animal继承下来的，当我们创建了一个Dog的实例c时，我们认为c的数据类型是Dog没错，但c同时也是Animal也没错，Dog本来就是Animal的一种！

所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：
&gt;&gt;&gt; b = Animal()
&gt;&gt;&gt; isinstance(b, Dog)
False


Dog可以看成Animal，但Animal不可以看成Dog。

要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：
def run_twice(animal):
    animal.run()
    animal.run()


当我们传入Animal的实例时，run_twice()就打印出：
&gt;&gt;&gt; run_twice(Animal())
Animal is running...
Animal is running...


当我们传入Dog的实例时，run_twice()就打印出：
&gt;&gt;&gt; run_twice(Dog())
Dog is running...
Dog is running...


当我们传入Cat的实例时，run_twice()就打印出：
&gt;&gt;&gt; run_twice(Cat())
Cat is running...
Cat is running...


看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：
class Tortoise(Animal):
    def run(self):
        print('Tortoise is running slowly...')


当我们调用run_twice()时，传入Tortoise的实例：
&gt;&gt;&gt; run_twice(Tortoise())
Tortoise is running slowly...
Tortoise is running slowly...


你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。

多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：

对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：

对扩展开放：允许新增Animal子类；

对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。

继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：



静态语言 vs 动态语言

对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。

对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：
class Timer(object):
    def run(self):
        print('Start...')


这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。

Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like
 object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。

小结

继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。

动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。


在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。

但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：
&gt;&gt;&gt; bart = Student('Bart Simpson', 98)
&gt;&gt;&gt; bart.score
98
&gt;&gt;&gt; bart.score = 59
&gt;&gt;&gt; bart.score
59


如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：
class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))


改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了：
&gt;&gt;&gt; bart = Student('Bart Simpson', 98)
&gt;&gt;&gt; bart.__name
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute '__name'


这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。

但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法：
class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score


如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法：
class Student(object):
    ...

    def set_score(self, score):
        self.__score = score


你也许会问，原先那种直接通过bart.score = 59也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：
class Student(object):
    ...

    def set_score(self, score):
        if 0 &lt;= score &lt;= 100:
            self.__score = score
        else:
            raise ValueError('bad score')


需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。

有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。

双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：
&gt;&gt;&gt; bart._Student__name
'Bart Simpson'


但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。

总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。


面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。

仍以Student类为例，在Python中，定义类是通过class关键字：
class Student(object):
    pass


class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。

定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的：
&gt;&gt;&gt; bart = Student()
&gt;&gt;&gt; bart
&lt;__main__.Student object at 0x10a67a590&gt;
&gt;&gt;&gt; Student
&lt;class '__main__.Student'&gt;


可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。

可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性：
&gt;&gt;&gt; bart.name = 'Bart Simpson'
&gt;&gt;&gt; bart.name
'Bart Simpson'


由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：
class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score


注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。

有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：
&gt;&gt;&gt; bart = Student('Bart Simpson', 59)
&gt;&gt;&gt; bart.name
'Bart Simpson'
&gt;&gt;&gt; bart.score
59


和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。

数据封装

面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：
&gt;&gt;&gt; def print_score(std):
...     print('%s: %s' % (std.name, std.score))
...
&gt;&gt;&gt; print_score(bart)
Bart Simpson: 59


但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法：
class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))


要定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入：
&gt;&gt;&gt; bart.print_score()
Bart Simpson: 59


这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。

封装的另一个好处是可以给Student类增加新的方法，比如get_grade：
class Student(object):
    ...

    def get_grade(self):
        if self.score &gt;= 90:
            return 'A'
        elif self.score &gt;= 60:
            return 'B'
        else:
            return 'C'


同样的，get_grade方法可以直接在实例变量上调用，不需要知道内部实现细节：
&gt;&gt;&gt; bart.get_grade()
'C'


小结

类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；

方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；

通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。

和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：
&gt;&gt;&gt; bart = Student('Bart Simpson', 59)
&gt;&gt;&gt; lisa = Student('Lisa Simpson', 87)
&gt;&gt;&gt; bart.age = 8
&gt;&gt;&gt; bart.age
8
&gt;&gt;&gt; lisa.age
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'age'


面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。

面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。

而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。

我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。

假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：
std1 = { 'name': 'Michael', 'score': 98 }
std2 = { 'name': 'Bob', 'score': 81 }


而处理学生成绩可以通过函数实现，比如打印学生的成绩：
def print_score(std):
    print('%s: %s' % (std['name'], std['score']))


如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来。
class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))


给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：
bart = Student('Bart Simpson', 59)
lisa = Student('Lisa Simpson', 87)
bart.print_score()
lisa.print_score()


面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。

所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。

面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。

小结

数据封装、继承和多态是面向对象的三大特点，我们后面会详细讲解。


面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。

面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。

而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。

我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。

假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：
std1 = { 'name': 'Michael', 'score': 98 }
std2 = { 'name': 'Bob', 'score': 81 }


而处理学生成绩可以通过函数实现，比如打印学生的成绩：
def print_score(std):
    print('%s: %s' % (std['name'], std['score']))


如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来。
class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))


给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：
bart = Student('Bart Simpson', 59)
lisa = Student('Lisa Simpson', 87)
bart.print_score()
lisa.print_score()


面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。

所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。

面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。

小结

数据封装、继承和多态是面向对象的三大特点，我们后面会详细讲解。


在Python中，安装第三方模块，是通过包管理工具pip完成的。

如果你正在使用Mac或Linux，安装pip本身这个步骤就可以跳过了。

如果你正在使用Windows，请参考安装Python一节的内容，确保安装时勾选了pip和Add
 python.exe to Path。

在命令提示符窗口下尝试运行pip，如果Windows提示未找到命令，可以重新运行安装程序添加pip。

注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是pip3。

现在，让我们来安装一个第三方库——Python Imaging Library，这是Python下非常强大的处理图像的工具库。不过，PIL目前只支持到Python 2.7，并且有年头没有更新了，因此，基于PIL的Pillow项目开发非常活跃，并且支持最新的Python 3。

一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是：
pip install Pillow


耐心等待下载并安装后，就可以使用Pillow了。

有了Pillow，处理图片易如反掌。随便找个图片生成缩略图：
&gt;&gt;&gt; from PIL import Image
&gt;&gt;&gt; im = Image.open('test.png')
&gt;&gt;&gt; print(im.format, im.size, im.mode)
PNG (400, 300) RGB
&gt;&gt;&gt; im.thumbnail((200, 100))
&gt;&gt;&gt; im.save('thumb.jpg', 'JPEG')


其他常用的第三方库还有MySQL的驱动：mysql-connector-python，用于科学计算的NumPy库：numpy，用于生成文本的模板工具Jinja2，等等。

模块搜索路径

当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：
&gt;&gt;&gt; import mymodule
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ImportError: No module named mymodule


默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', '/Library/Frameworks/Python.framework/Versions/3.4/lib/python34.zip', '/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4', '/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/plat-darwin', '/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/lib-dynload', '/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages']


如果我们要添加自己的搜索目录，有两种方法：

一是直接修改sys.path，添加要搜索的目录：
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append('/Users/michael/my_py_scripts')


这种方法是在运行时修改，运行结束后失效。

第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。


Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。

我们以内建的sys模块为例，编写一个hello的模块：
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

' a test module '

__author__ = 'Michael Liao'

import sys

def test():
    args = sys.argv
    if len(args)==1:
            print('Hello, world!')
    elif len(args)==2:
        print('Hello, %s!' % args[1])
    else:
        print('Too many arguments!')

if __name__=='__main__':
    test()


第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；

第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；

第6行使用__author__变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；

以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。

后面开始就是真正的代码部分。

你可能注意到了，使用sys模块的第一步，就是导入该模块：
import sys


导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。

sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：

运行python3 hello.py获得的sys.argv就是['hello.py']；

运行python3 hello.py Michael获得的sys.argv就是['hello.py',
 'Michael]。

最后，注意到这两行代码：
if __name__=='__main__':
    test()


当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。

我们可以用命令行运行hello.py看看效果：
$ python3 hello.py
Hello, world!
$ python hello.py Michael
Hello, Michael!


如果启动Python交互环境，再导入hello模块：
$ python3
Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) 
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import hello
&gt;&gt;&gt;


导入时，没有打印Hello, word!，因为没有执行test()函数。

调用hello.test()时，才能打印出Hello,
 word!：
&gt;&gt;&gt; hello.test()
Hello, world!


作用域

在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。

正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；

类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名；

类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等；

之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。

private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：
def _private_1(name):
    return 'Hello, %s' % name

def _private_2(name):
    return 'Hi, %s' % name

def greeting(name):
    if len(name) &gt; 3:
        return _private_1(name)
    else:
        return _private_2(name)


我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：

外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。


在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。

为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。

使用模块有什么好处？

最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。

使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。点这里查看Python的所有内置函数。

你也许还想到，如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。

举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。

现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如mycompany，按照如下目录存放：



引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了mycompany.xyz。

请注意，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。

类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：



文件www.py的模块名就是mycompany.web.www，两个文件utils.py的模块名分别是mycompany.utils和mycompany.web.utils。

自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。


Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。

在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：

int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：
&gt;&gt;&gt; int('12345')
12345


但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：
&gt;&gt;&gt; int('12345', base=8)
5349
&gt;&gt;&gt; int('12345', 16)
74565


假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：
def int2(x, base=2):
    return int(x, base)


这样，我们转换二进制就非常方便了：
&gt;&gt;&gt; int2('1000000')
64
&gt;&gt;&gt; int2('1010101')
85


functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：
&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2('1000000')
64
&gt;&gt;&gt; int2('1010101')
85


所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。

注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：
&gt;&gt;&gt; int2('1000000', base=10)
1000000


最后，创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：
int2 = functools.partial(int, base=2)


实际上固定了int()函数的关键字参数base，也就是：
int2('10010')


相当于：
kw = { 'base': 2 }
int('10010', **kw)


当传入：
max2 = functools.partial(max, 10)


实际上会把10作为*args的一部分自动加到左边，也就是：
max2(5, 6, 7)


相当于：
args = (10, 5, 6, 7)
max(*args)


结果为10。

小结

当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。


由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。
&gt;&gt;&gt; def now():
...     print('2015-3-25')
...
&gt;&gt;&gt; f = now
&gt;&gt;&gt; f()
2015-3-25


函数对象有一个__name__属性，可以拿到函数的名字：
&gt;&gt;&gt; now.__name__
'now'
&gt;&gt;&gt; f.__name__
'now'


现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。

本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：
def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper


观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：
@log
def now():
    print('2015-3-25')


调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：
&gt;&gt;&gt; now()
call now():
2015-3-25


把@log放到now()函数的定义处，相当于执行了语句：
now = log(now)


由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。

wrapper()函数的参数定义是(*args,
 **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。

如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：
def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator


这个3层嵌套的decorator用法如下：
@log('execute')
def now():
    print('2015-3-25')


执行结果如下：
&gt;&gt;&gt; now()
execute now():
2015-3-25


和两层嵌套的decorator相比，3层嵌套的效果是这样的：
&gt;&gt;&gt; now = log('execute')(now)


我们来剖析上面的语句，首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。

以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的'now'变成了'wrapper'：
&gt;&gt;&gt; now.__name__
'wrapper'


因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。

不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：
import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper


或者针对带参数的decorator：
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator


import functools是导入functools模块。模块的概念稍候讲解。现在，只需记住在定义wrapper()的前面加上@functools.wraps(func)即可。

小结

在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。

decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。

请编写一个decorator，能在函数调用的前后打印出'begin call'和'end
 call'的日志。

再思考一下能否写出一个@log的decorator，使它既支持：
@log
def f():
    pass


又支持：
@log('execute')
def f():
    pass


当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。

在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：
&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]


通过对比可以看出，匿名函数lambda x: x * x实际上就是：
def f(x):
    return x * x


关键字lambda表示匿名函数，冒号前面的x表示函数参数。

匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。

用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：
&gt;&gt;&gt; f = lambda x: x * x
&gt;&gt;&gt; f
&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;
&gt;&gt;&gt; f(5)
25


同样，也可以把匿名函数作为返回值返回，比如：
def build(x, y):
    return lambda: x * x + y * y


小结

Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。


函数作为返回值

高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。

我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：
def calc_sum(*args):
    ax = 0
    for n in args:
        ax = ax + n
    return ax


但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum


当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：
&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;


调用函数f时，才真正计算求和的结果：
&gt;&gt;&gt; f()
25


在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。

请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：
&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f1==f2
False


f1()和f2()的调用结果互不影响。

闭包

注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。

另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()


在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。

你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：
&gt;&gt;&gt; f1()
9
&gt;&gt;&gt; f2()
9
&gt;&gt;&gt; f3()
9


全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。

返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。

如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs


再看看结果：
&gt;&gt;&gt; f1, f2, f3 = count()
&gt;&gt;&gt; f1()
1
&gt;&gt;&gt; f2()
4
&gt;&gt;&gt; f3()
9


缺点是代码较长，可利用lambda函数缩短代码。

小结

一个函数可以返回一个计算结果，也可以返回一个函数。

返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。


排序算法

排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。

Python内置的sorted()函数就可以对list进行排序：
&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]


此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：
&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]


key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：
list = [36, 5, -12, 9, -21]

keys = [36, 5,  12, 9,  21]


然后sorted()函数按照keys进行排序，并按照对应关系返回list相应的元素：
keys排序结果 =&gt; [5, 9,  12,  21, 36]
                |  |    |    |   |
最终结果     =&gt; [5, 9, -12, -21, 36]


我们再看一个字符串排序的例子：
&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'])
['Credit', 'Zoo', 'about', 'bob']


默认情况下，对字符串排序，是按照ASCII的大小比较的，由于'Z' &lt; 'a'，结果，大写字母Z会排在小写字母a的前面。

现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。

这样，我们给sorted传入key函数，即可实现忽略大小写的排序：
&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']


要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：
&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']


从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。

小结

sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数。


Python内建的filter()函数用于过滤序列。

和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。

例如，在一个list中，删掉偶数，只保留奇数，可以这么写：
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]


把一个序列中的空字符串删掉，可以这么写：
def not_empty(s):
    return s and s.strip()

list(filter(not_empty, ['A', '', 'B', None, 'C', '  ']))
# 结果: ['A', 'B', 'C']


可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。

注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。

用filter求素数

计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：

首先，列出从2开始的所有自然数，构造一个序列：

2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...

取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：

3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
14, 15, 16, 17, 18, 19, 20, ...

取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：

5, 6, 7, 8, 9, 10, 11, 12, 13,
14, 15, 16, 17, 18, 19, 20, ...

取新序列的第一个数5，然后用5把序列的5的倍数筛掉：

7, 8, 9, 10, 11, 12, 13, 14,
15, 16, 17, 18, 19, 20, ...

不断筛下去，就可以得到所有的素数。

用Python来实现这个算法，可以先构造一个从3开始的奇数序列：
def _odd_iter():
    n = 1
    while True:
        n = n + 2
        yield n


注意这是一个生成器，并且是一个无限序列。

然后定义一个筛选函数：
def _not_divisible(n):
    return lambda x: x % n &gt; 0


最后，定义一个生成器，不断返回下一个素数：
def primes():
    yield 2
    it = _odd_iter() # 初始序列
    while True:
        n = next(it) # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列


这个生成器先返回第一个素数2，然后，利用filter()不断产生筛选后的新的序列。

由于primes()也是一个无限序列，所以调用时需要设置一个退出循环的条件：
# 打印1000以内的素数:
for n in primes():
    if n &lt; 1000:
        print(n)
    else:
        break


注意到Iterator是惰性计算的序列，所以我们可以用Python表示“全体自然数”，“全体素数”这样的序列，而代码非常简洁。

小结

filter()的作用是从一个序列中筛出符合条件的元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。


Python内建了map()和reduce()函数。

如果你读过Google的那篇大名鼎鼎的论文“MapReduce: Simplified Data Processing on Large Clusters”，你就能大概明白map/reduce的概念。

我们先看map。map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。

举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个list

[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：



现在，我们用Python代码实现：
&gt;&gt;&gt; def f(x):
...     return x * x
...
&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]


map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。

你可能会想，不需要map()函数，写一个循环，也可以计算出结果：
L = []
for n in [1, 2, 3, 4, 5, 6, 7, 8, 9]:
    L.append(f(n))
print(L)


的确可以，但是，从上面的循环代码，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list”吗？

所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：
&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
['1', '2', '3', '4', '5', '6', '7', '8', '9']


只需要一行代码。

再看reduce的用法。reduce把一个函数作用在一个序列[x1,
 x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)


比方说对一个序列求和，就可以用reduce实现：
&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def add(x, y):
...     return x + y
...
&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])
25


当然求和运算可以直接用Python内建函数sum()，没必要动用reduce。

但是如果要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场：
&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def fn(x, y):
...     return x * 10 + y
...
&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])
13579


这个例子本身没多大用处，但是，如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：
&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def fn(x, y):
...     return x * 10 + y
...
&gt;&gt;&gt; def char2num(s):
...     return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
...
&gt;&gt;&gt; reduce(fn, map(char2num, '13579'))
13579


整理成一个str2int的函数就是：
from functools import reduce

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
    return reduce(fn, map(char2num, s))


还可以用lambda函数进一步简化成：
from functools import reduce

def char2num(s):
    return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))


也就是说，假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！

lambda函数的用法在后面介绍。


高阶函数英文叫Higher-order function。什么是高阶函数？我们以实际代码为例子，一步一步深入概念。

变量可以指向函数

以Python内置的求绝对值的函数abs()为例，调用该函数用以下代码：
&gt;&gt;&gt; abs(-10)
10


但是，如果只写abs呢？
&gt;&gt;&gt; abs
&lt;built-in function abs&gt;


可见，abs(-10)是函数调用，而abs是函数本身。

要获得函数调用结果，我们可以把结果赋值给变量：
&gt;&gt;&gt; x = abs(-10)
&gt;&gt;&gt; x
10


但是，如果把函数本身赋值给变量呢？
&gt;&gt;&gt; f = abs
&gt;&gt;&gt; f
&lt;built-in function abs&gt;


结论：函数本身也可以赋值给变量，即：变量可以指向函数。

如果一个变量指向了一个函数，那么，可否通过该变量来调用这个函数？用代码验证一下：
&gt;&gt;&gt; f = abs
&gt;&gt;&gt; f(-10)
10


成功！说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。

函数名也是变量

那么函数名是什么呢？函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！

如果把abs指向其他对象，会有什么情况发生？
&gt;&gt;&gt; abs = 10
&gt;&gt;&gt; abs(-10)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'int' object is not callable


把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！

当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境。

注：由于abs函数实际上是定义在import
 builtins模块中的，所以要让修改abs变量的指向在其它模块也生效，要用import
 builtins; builtins.abs = 10。

传入函数

既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。

一个最简单的高阶函数：
def add(x, y, f):
    return f(x) + f(y)


当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：
x = -5
y = 6
f = abs
f(x) + f(y) ==&gt; abs(-5) + abs(6) ==&gt; 11
return 11


用代码验证一下：
&gt;&gt;&gt; add(-5, 6, abs)
11


编写高阶函数，就是让函数的参数能够接收别的函数。

小结

把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。


函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。

而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。

我们首先要搞明白计算机（Computer）和计算（Compute）的概念。

在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。

而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。

对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。

函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。

函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！

Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。


我们已经知道，可以直接作用于for循环的数据类型有以下几种：

一类是集合数据类型，如list、tuple、dict、set、str等；

一类是generator，包括生成器和带yield的generator
 function。

这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。

可以使用isinstance()判断一个对象是否是Iterable对象：
&gt;&gt;&gt; from collections import Iterable
&gt;&gt;&gt; isinstance([], Iterable)
True
&gt;&gt;&gt; isinstance({}, Iterable)
True
&gt;&gt;&gt; isinstance('abc', Iterable)
True
&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)
True
&gt;&gt;&gt; isinstance(100, Iterable)
False


而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。

可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。

可以使用isinstance()判断一个对象是否是Iterator对象：
&gt;&gt;&gt; from collections import Iterator
&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)
True
&gt;&gt;&gt; isinstance([], Iterator)
False
&gt;&gt;&gt; isinstance({}, Iterator)
False
&gt;&gt;&gt; isinstance('abc', Iterator)
False


生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。

把list、dict、str等Iterable变成Iterator可以使用iter()函数：
&gt;&gt;&gt; isinstance(iter([]), Iterator)
True
&gt;&gt;&gt; isinstance(iter('abc'), Iterator)
True


你可能会问，为什么list、dict、str等数据类型不是Iterator？

这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。

Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。

小结

凡是可作用于for循环的对象都是Iterable类型；

凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；

集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。

Python的for循环本质上就是通过不断调用next()函数实现的，例如：
for x in [1, 2, 3, 4, 5]:
    pass


实际上完全等价于：
# 首先获得Iterator对象:
it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
    try:
        # 获得下一个值:
        x = next(it)
    except StopIteration:
        # 遇到StopIteration就退出循环
        break


通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。

所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。

要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：
&gt;&gt;&gt; L = [x * x for x in range(10)]
&gt;&gt;&gt; L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;


创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。

我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？

如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：
&gt;&gt;&gt; next(g)
0
&gt;&gt;&gt; next(g)
1
&gt;&gt;&gt; next(g)
4
&gt;&gt;&gt; next(g)
9
&gt;&gt;&gt; next(g)
16
&gt;&gt;&gt; next(g)
25
&gt;&gt;&gt; next(g)
36
&gt;&gt;&gt; next(g)
49
&gt;&gt;&gt; next(g)
64
&gt;&gt;&gt; next(g)
81
&gt;&gt;&gt; next(g)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration


我们讲过，generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。

当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：
&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; for n in g:
...     print(n)
... 
0
1
4
9
16
25
36
49
64
81


所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。

generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。

比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：

1, 1, 2, 3, 5, 8, 13, 21, 34, ...

斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：
def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        print(b)
        a, b = b, a + b
        n = n + 1
    return 'done'


上面的函数可以输出斐波那契数列的前N个数：
&gt;&gt;&gt; fib(6)
1
1
2
3
5
8
'done'


仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。

也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print(b)改为yield
 b就可以了：
def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'


这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：
&gt;&gt;&gt; f = fib(6)
&gt;&gt;&gt; f
&lt;generator object fib at 0x104feaaa0&gt;


这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。

举个简单的例子，定义一个generator，依次返回数字1，3，5：
def odd():
    print('step 1')
    yield 1
    print('step 2')
    yield(3)
    print('step 3')
    yield(5)


调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：
&gt;&gt;&gt; o = odd()
&gt;&gt;&gt; next(o)
step 1
1
&gt;&gt;&gt; next(o)
step 2
3
&gt;&gt;&gt; next(o)
step 3
5
&gt;&gt;&gt; next(o)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration


可以看到，odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。

回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。

同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：
&gt;&gt;&gt; for n in fib(6):
...     print(n)
...
1
1
2
3
5
8


但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：
&gt;&gt;&gt; g = fib(6)
&gt;&gt;&gt; while True:
...     try:
...         x = next(g)
...         print('g:', x)
...     except StopIteration as e:
...         print('Generator return value:', e.value)
...         break
...
g: 1
g: 1
g: 2
g: 3
g: 5
g: 8
Generator return value: done


关于如何捕获错误，后面的错误处理还会详细讲解。

小结

generator是非常强大的工具，在Python中，可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。

要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。

请注意区分普通函数和generator函数，普通函数调用直接返回结果：
&gt;&gt;&gt; r = abs(6)
&gt;&gt;&gt; r
6


generator函数的“调用”实际返回一个generator对象：
&gt;&gt;&gt; g = fib(6)
&gt;&gt;&gt; g
&lt;generator object fib at 0x1022ef948&gt;


列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。

举个例子，要生成list 
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：
&gt;&gt;&gt; list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：
&gt;&gt;&gt; L = []
&gt;&gt;&gt; for x in range(1, 11):
...    L.append(x * x)
...
&gt;&gt;&gt; L
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]


但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：
&gt;&gt;&gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]


写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。

for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：
&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]


还可以使用两层循环，可以生成全排列：
&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']


三层和三层以上的循环就很少用到了。

运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：
&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到
&gt;&gt;&gt; [d for d in os.listdir('.')] # os.listdir可以列出文件和目录
['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode']


for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：
&gt;&gt;&gt; d = {'x': 'A', 'y': 'B', 'z': 'C' }
&gt;&gt;&gt; for k, v in d.items():
...     print(k, '=', v)
...
y = B
x = A
z = C


因此，列表生成式也可以使用两个变量来生成list：
&gt;&gt;&gt; d = {'x': 'A', 'y': 'B', 'z': 'C' }
&gt;&gt;&gt; [k + '=' + v for k, v in d.items()]
['y=B', 'x=A', 'z=C']


最后把一个list中所有的字符串变成小写：
&gt;&gt;&gt; L = ['Hello', 'World', 'IBM', 'Apple']
&gt;&gt;&gt; [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']

如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法，所以列表生成式会报错：
&gt;&gt;&gt; L = ['Hello', 'World', 18, 'Apple', None]
&gt;&gt;&gt; [s.lower() for s in L]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 1, in &lt;listcomp&gt;
AttributeError: 'int' object has no attribute 'lower'


使用内建的isinstance函数可以判断一个变量是不是字符串：
&gt;&gt;&gt; x = 'abc'
&gt;&gt;&gt; y = 123
&gt;&gt;&gt; isinstance(x, str)
True
&gt;&gt;&gt; isinstance(y, str)
False

小结

运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。


迭代

阅读: 123641



如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。

在Python中，迭代是通过for ... in来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码：
for (i=0; i&lt;list.length; i++) {
    n = list[i];
}


可以看出，Python的for循环抽象程度要高于Java的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。

list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：
&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; for key in d:
...     print(key)
...
a
c
b


因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。

默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for
 k, v in d.items()。

由于字符串也是可迭代对象，因此，也可以作用于for循环：
&gt;&gt;&gt; for ch in 'ABC':
...     print(ch)
...
A
B
C


所以，当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。

那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：
&gt;&gt;&gt; from collections import Iterable
&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代
True
&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代
True
&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代
False


最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：
&gt;&gt;&gt; for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)
...
0 A
1 B
2 C


上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：
&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:
...     print(x, y)
...
1 1
2 4
3 9


小结

任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。



掌握了Python的数据类型、语句和函数，基本上就可以编写出很多有用的程序了。

比如构造一个1, 3, 5, 7, ..., 99的列表，可以通过循环实现：
L = []
n = 1
while n &lt;= 99:
    L.append(n)
    n = n + 2


取list的前一半的元素，也可以通过循环实现。

但是在Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。

基于这一思想，我们来介绍Python中非常有用的高级特性，1行代码能实现的功能，决不写5行代码。请始终牢记，代码越少，开发效率越高。



取一个list或tuple的部分元素是非常常见的操作。比如，一个list如下：
&gt;&gt;&gt; L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']


取前3个元素，应该怎么做？

笨办法：
&gt;&gt;&gt; [L[0], L[1], L[2]]
['Michael', 'Sarah', 'Tracy']


之所以是笨办法是因为扩展一下，取前N个元素就没辙了。

取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：
&gt;&gt;&gt; r = []
&gt;&gt;&gt; n = 3
&gt;&gt;&gt; for i in range(n):
...     r.append(L[i])
... 
&gt;&gt;&gt; r
['Michael', 'Sarah', 'Tracy']


对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。

对应上面的问题，取前3个元素，用一行代码就可以完成切片：
&gt;&gt;&gt; L[0:3]
['Michael', 'Sarah', 'Tracy']


L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。

如果第一个索引是0，还可以省略：
&gt;&gt;&gt; L[:3]
['Michael', 'Sarah', 'Tracy']


也可以从索引1开始，取出2个元素出来：
&gt;&gt;&gt; L[1:3]
['Sarah', 'Tracy']


类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：
&gt;&gt;&gt; L[-2:]
['Bob', 'Jack']
&gt;&gt;&gt; L[-2:-1]
['Bob']


记住倒数第一个元素的索引是-1。

切片操作十分有用。我们先创建一个0-99的数列：
&gt;&gt;&gt; L = list(range(100))
&gt;&gt;&gt; L
[0, 1, 2, 3, ..., 99]


可以通过切片轻松取出某一段数列。比如前10个数：
&gt;&gt;&gt; L[:10]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


后10个数：
&gt;&gt;&gt; L[-10:]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]


前11-20个数：
&gt;&gt;&gt; L[10:20]
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]


前10个数，每两个取一个：
&gt;&gt;&gt; L[:10:2]
[0, 2, 4, 6, 8]


所有数，每5个取一个：
&gt;&gt;&gt; L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]


甚至什么都不写，只写[:]就可以原样复制一个list：
&gt;&gt;&gt; L[:]
[0, 1, 2, 3, ..., 99]


tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：
&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)


字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：
&gt;&gt;&gt; 'ABCDEFG'[:3]
'ABC'
&gt;&gt;&gt; 'ABCDEFG'[::2]
'ACEG'


在很多编程语言中，针对字符串提供了很多各种截取函数（例如，substring），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。

小结

有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。



在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。

举个例子，我们来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：

fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n

所以，fact(n)可以表示为n
 x fact(n-1)，只有n=1时需要特殊处理。

于是，fact(n)用递归的方式写出来就是：
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)


上面就是一个递归函数。可以试试：
&gt;&gt;&gt; fact(1)
1
&gt;&gt;&gt; fact(5)
120
&gt;&gt;&gt; fact(100)
93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000


如果我们计算fact(5)，可以根据函数定义看到计算过程如下：
===&gt; fact(5)
===&gt; 5 * fact(4)
===&gt; 5 * (4 * fact(3))
===&gt; 5 * (4 * (3 * fact(2)))
===&gt; 5 * (4 * (3 * (2 * fact(1))))
===&gt; 5 * (4 * (3 * (2 * 1)))
===&gt; 5 * (4 * (3 * 2))
===&gt; 5 * (4 * 6)
===&gt; 5 * 24
===&gt; 120


递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。

使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)：
&gt;&gt;&gt; fact(1000)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 4, in fact
  ...
  File "&lt;stdin&gt;", line 4, in fact
RuntimeError: maximum recursion depth exceeded in comparison


解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

上面的fact(n)函数由于return
 n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)


可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num
 - 1和num * product在函数调用前就会被计算，不影响函数调用。

fact(5)对应的fact_iter(5,
 1)的调用如下：
===&gt; fact_iter(5, 1)
===&gt; fact_iter(4, 5)
===&gt; fact_iter(3, 20)
===&gt; fact_iter(2, 60)
===&gt; fact_iter(1, 120)
===&gt; 120


尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。

遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。

小结

使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。

针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。

Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。


定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。

Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。

位置参数

我们先写一个计算x2的函数：
def power(x):
    return x * x


对于power(x)函数，参数x就是一个位置参数。

当我们调用power函数时，必须传入有且仅有的一个参数x：
&gt;&gt;&gt; power(5)
25
&gt;&gt;&gt; power(15)
225


现在，如果我们要计算x3怎么办？可以再定义一个power3函数，但是如果要计算x4、x5……怎么办？我们不可能定义无限多个函数。

你也许想到了，可以把power(x)修改为power(x,
 n)，用来计算xn，说干就干：
def power(x, n):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s


对于这个修改后的power(x, n)函数，可以计算任意n次方：
&gt;&gt;&gt; power(5, 2)
25
&gt;&gt;&gt; power(5, 3)
125


修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。

默认参数

新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：
&gt;&gt;&gt; power(5)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: power() missing 1 required positional argument: 'n'


Python的错误信息很明确：调用函数power()缺少了一个位置参数n。

这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：
def power(x, n=2):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s


这样，当我们调用power(5)时，相当于调用power(5,
 2)：
&gt;&gt;&gt; power(5)
25
&gt;&gt;&gt; power(5, 2)
25


而对于n &gt; 2的其他情况，就必须明确地传入n，比如power(5,
 3)。

从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：

一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；

二是如何设置默认参数。

当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。

使用默认参数有什么好处？最大的好处是能降低调用函数的难度。

举个例子，我们写个一年级小学生注册的函数，需要传入name和gender两个参数：
def enroll(name, gender):
    print('name:', name)
    print('gender:', gender)


这样，调用enroll()函数只需要传入两个参数：
&gt;&gt;&gt; enroll('Sarah', 'F')
name: Sarah
gender: F


如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。

我们可以把年龄和城市设为默认参数：
def enroll(name, gender, age=6, city='Beijing'):
    print('name:', name)
    print('gender:', gender)
    print('age:', age)
    print('city:', city)


这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：
&gt;&gt;&gt; enroll('Sarah', 'F')
name: Sarah
gender: F
age: 6
city: Beijing


只有与默认参数不符的学生才需要提供额外的信息：
enroll('Bob', 'M', 7)
enroll('Adam', 'M', city='Tianjin')


可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。

有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll('Bob', 'M', 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。

也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll('Adam', 'M', city='Tianjin')，意思是，city参数用传进去的值，其他默认参数继续使用默认值。

默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：

先定义一个函数，传入一个list，添加一个END再返回：
def add_end(L=[]):
    L.append('END')
    return L


当你正常调用时，结果似乎不错：
&gt;&gt;&gt; add_end([1, 2, 3])
[1, 2, 3, 'END']
&gt;&gt;&gt; add_end(['x', 'y', 'z'])
['x', 'y', 'z', 'END']


当你使用默认参数调用时，一开始结果也是对的：
&gt;&gt;&gt; add_end()
['END']


但是，再次调用add_end()时，结果就不对了：
&gt;&gt;&gt; add_end()
['END', 'END']
&gt;&gt;&gt; add_end()
['END', 'END', 'END']


很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了'END'后的list。

原因解释如下：

Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。

所以，定义默认参数要牢记一点：默认参数必须指向不变对象！

要修改上面的例子，我们可以用None这个不变对象来实现：
def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L


现在，无论调用多少次，都不会有问题：
&gt;&gt;&gt; add_end()
['END']
&gt;&gt;&gt; add_end()
['END']


为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。

可变参数

在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。

我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2
 + ……。

要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：
def calc(numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum


但是调用的时候，需要先组装出一个list或tuple：
&gt;&gt;&gt; calc([1, 2, 3])
14
&gt;&gt;&gt; calc((1, 3, 5, 7))
84


如果利用可变参数，调用函数的方式可以简化成这样：
&gt;&gt;&gt; calc(1, 2, 3)
14
&gt;&gt;&gt; calc(1, 3, 5, 7)
84


所以，我们把函数的参数改为可变参数：
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum


定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：
&gt;&gt;&gt; calc(1, 2)
5
&gt;&gt;&gt; calc()
0


如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：
&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])
14


这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：
&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(*nums)
14


*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。

关键字参数

可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)


函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：
&gt;&gt;&gt; person('Michael', 30)
name: Michael age: 30 other: {}


也可以传入任意个数的关键字参数：
&gt;&gt;&gt; person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}


关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。

和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：
&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}
&gt;&gt;&gt; person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}


当然，上面复杂的调用可以用简化的写法：
&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}
&gt;&gt;&gt; person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}


**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。

命名关键字参数

对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。

仍以person()函数为例，我们希望检查是否有city和job参数：
def person(name, age, **kw):
    if 'city' in kw:
        # 有city参数
        pass
    if 'job' in kw:
        # 有job参数
        pass
    print('name:', name, 'age:', age, 'other:', kw)


但是调用者仍可以传入不受限制的关键字参数：
&gt;&gt;&gt; person('Jack', 24, city='Beijing', addr='Chaoyang', zipcode=123456)


如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：
def person(name, age, *, city, job):
    print(name, age, city, job)


和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。

调用方式如下：
&gt;&gt;&gt; person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer


如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：
def person(name, age, *args, city, job):
    print(name, age, args, city, job)


命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：
&gt;&gt;&gt; person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: person() takes 2 positional arguments but 4 were given


由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。

命名关键字参数可以有缺省值，从而简化调用：
def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)


由于命名关键字参数city具有默认值，调用时，可不传入city参数：
&gt;&gt;&gt; person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer


使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：
def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass


参数组合

在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

比如定义一个函数，包含上述若干种参数：
def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)


在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。
&gt;&gt;&gt; f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
&gt;&gt;&gt; f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
&gt;&gt;&gt; f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}


最神奇的是通过一个tuple和dict，你也可以调用上述函数：
&gt;&gt;&gt; args = (1, 2, 3, 4)
&gt;&gt;&gt; kw = {'d': 99, 'x': '#'}
&gt;&gt;&gt; f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
&gt;&gt;&gt; args = (1, 2, 3)
&gt;&gt;&gt; kw = {'d': 88, 'x': '#'}
&gt;&gt;&gt; f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}


所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。

小结

Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。

默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！

要注意定义可变参数和关键字参数的语法：

*args是可变参数，args接收的是一个tuple；

**kw是关键字参数，kw接收的是一个dict。

以及调用函数时如何传入可变参数和关键字参数的语法：

可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1,
 2, 3))；

关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a':
 1, 'b': 2})。

使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。

命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。

定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。


Python内置了很多有用的函数，我们可以直接调用。

要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。可以直接从Python的官方网站查看文档：

http://docs.python.org/3/library/functions.html#abs

也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。

调用abs函数：
&gt;&gt;&gt; abs(100)
100
&gt;&gt;&gt; abs(-20)
20
&gt;&gt;&gt; abs(12.34)
12.34


调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：
&gt;&gt;&gt; abs(1, 2)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: abs() takes exactly one argument (2 given)


如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：
&gt;&gt;&gt; abs('a')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: bad operand type for abs(): 'str'


而max函数max()可以接收任意多个参数，并返回最大的那个：
&gt;&gt;&gt; max(1, 2)
2
&gt;&gt;&gt; max(2, 3, 1, -5)
3


数据类型转换

Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数：
&gt;&gt;&gt; int('123')
123
&gt;&gt;&gt; int(12.34)
12
&gt;&gt;&gt; float('12.34')
12.34
&gt;&gt;&gt; str(1.23)
'1.23'
&gt;&gt;&gt; str(100)
'100'
&gt;&gt;&gt; bool(1)
True
&gt;&gt;&gt; bool('')
False


函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：
&gt;&gt;&gt; a = abs # 变量a指向abs函数
&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数
1

小结

调用Python的函数，需要根据函数定义，传入正确的参数。如果函数调用出错，一定要学会看错误信息，所以英文很重要！


我们知道圆的面积计算公式为：

S = πr2

当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：
r1 = 12.34
r2 = 9.08
r3 = 73.1
s1 = 3.14 * r1 * r1
s2 = 3.14 * r2 * r2
s3 = 3.14 * r3 * r3


当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。

有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用s
 = area_of_circle(x)，而函数area_of_circle本身只需要写一次，就可以多次调用。

基本上所有的高级语言都支持函数，Python也不例外。Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。

抽象

抽象是数学中非常常见的概念。举个例子：

计算数列的和，比如：1 + 2 + 3 + ... + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1
 + 2 + 3 + ... + 100记作：

100

∑n

n=1

这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。

而且，这种抽象记法是可扩展的，比如：

100

∑(n2+1)

n=1

还原成加法运算就变成了：

(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1)

可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。

写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。


dict

Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。

举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：
names = ['Michael', 'Bob', 'Tracy']
scores = [95, 75, 85]


给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。

如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：
&gt;&gt;&gt; d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
&gt;&gt;&gt; d['Michael']
95


为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。

第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。

dict就是第二种实现方式，给定一个名字，比如'Michael'，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。

你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。

把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：
&gt;&gt;&gt; d['Adam'] = 67
&gt;&gt;&gt; d['Adam']
67


由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：
&gt;&gt;&gt; d['Jack'] = 90
&gt;&gt;&gt; d['Jack']
90
&gt;&gt;&gt; d['Jack'] = 88
&gt;&gt;&gt; d['Jack']
88


如果key不存在，dict就会报错：
&gt;&gt;&gt; d['Thomas']
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'Thomas'


要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：
&gt;&gt;&gt; 'Thomas' in d
False


二是通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value：
&gt;&gt;&gt; d.get('Thomas')
&gt;&gt;&gt; d.get('Thomas', -1)
-1


注意：返回None的时候Python的交互式命令行不显示结果。

要删除一个key，用pop(key)方法，对应的value也会从dict中删除：
&gt;&gt;&gt; d.pop('Bob')
75
&gt;&gt;&gt; d
{'Michael': 95, 'Tracy': 85}


请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。

和list比较，dict有以下几个特点：

查找和插入的速度极快，不会随着key的增加而变慢；需要占用大量的内存，内存浪费多。

而list相反：

查找和插入的时间随着元素的增加而增加；占用空间小，浪费内存很少。

所以，dict是用空间来换取时间的一种方法。

dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。

这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。

要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：
&gt;&gt;&gt; key = [1, 2, 3]
&gt;&gt;&gt; d[key] = 'a list'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'


set

set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。

要创建一个set，需要提供一个list作为输入集合：
&gt;&gt;&gt; s = set([1, 2, 3])
&gt;&gt;&gt; s
{1, 2, 3}


注意，传入的参数[1, 2, 3]是一个list，而显示的{1,
 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。

重复元素在set中自动被过滤：
&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])
&gt;&gt;&gt; s
{1, 2, 3}


通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：
&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; s
{1, 2, 3, 4}
&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; s
{1, 2, 3, 4}


通过remove(key)方法可以删除元素：
&gt;&gt;&gt; s.remove(4)
&gt;&gt;&gt; s
{1, 2, 3}


set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：
&gt;&gt;&gt; s1 = set([1, 2, 3])
&gt;&gt;&gt; s2 = set([2, 3, 4])
&gt;&gt;&gt; s1 &amp; s2
{2, 3}
&gt;&gt;&gt; s1 | s2
{1, 2, 3, 4}


set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。

再议不可变对象

上面我们讲了，str是不变对象，而list是可变对象。

对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：
&gt;&gt;&gt; a = ['c', 'b', 'a']
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; a
['a', 'b', 'c']


而对于不可变对象，比如str，对str进行操作呢：
&gt;&gt;&gt; a = 'abc'
&gt;&gt;&gt; a.replace('a', 'A')
'Abc'
&gt;&gt;&gt; a
'abc'


虽然字符串有个replace()方法，也确实变出了'Abc'，但变量a最后仍是'abc'，应该怎么理解呢？

我们先把代码改成下面这样：
&gt;&gt;&gt; a = 'abc'
&gt;&gt;&gt; b = a.replace('a', 'A')
&gt;&gt;&gt; b
'Abc'
&gt;&gt;&gt; a
'abc'


要始终牢记的是，a是变量，而'abc'才是字符串对象！有些时候，我们经常说，对象a的内容是'abc'，但其实是指，a本身是一个变量，它指向的对象的内容才是'abc'：



当我们调用a.replace('a', 'A')时，实际上调用方法replace是作用在字符串对象'abc'上的，而这个方法虽然名字叫replace，但却没有改变字符串'abc'的内容。相反，replace方法创建了一个新字符串'Abc'并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串'abc'，但变量b却指向新字符串'Abc'了：



所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。

小结

使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。

tuple虽然是不变对象，但试试把(1, 2, 3)和(1,
 [2, 3])放入dict或set中，并解释结果。


循环

要计算1+2+3，我们可以直接写表达式：
&gt;&gt;&gt; 1 + 2 + 3
6


要计算1+2+3+...+10，勉强也能写出来。

但是，要计算1+2+3+...+10000，直接写表达式就不可能了。

为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。

Python的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来，看例子：
names = ['Michael', 'Bob', 'Tracy']
for name in names:
    print(name)


执行这段代码，会依次打印names的每一个元素：
Michael
Bob
Tracy


所以for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。

再比如我们想计算1-10的整数之和，可以用一个sum变量做累加：
sum = 0
for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
    sum = sum + x
print(sum)


如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：
&gt;&gt;&gt; list(range(5))
[0, 1, 2, 3, 4]


range(101)就可以生成0-100的整数序列，计算如下：
sum = 0
for x in range(101):
    sum = sum + x
print(sum)


请自行运行上述代码，看看结果是不是当年高斯同学心算出的5050。

第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：
sum = 0
n = 99
while n &gt; 0:
    sum = sum + n
    n = n - 2
print(sum)


在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。

小结

循环是让计算机做重复任务的有效的方法，有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。


条件判断

计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。

比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用if语句实现：
age = 20
if age &gt;= 18:
    print('your age is', age)
    print('adult')


根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。

也可以给if添加一个else语句，意思是，如果if判断是False，不要执行if的内容，去把else执行了：
age = 3
if age &gt;= 18:
    print('your age is', age)
    print('adult')
else:
    print('your age is', age)
    print('teenager')


注意不要少写了冒号:。

当然上面的判断是很粗略的，完全可以用elif做更细致的判断：
age = 3
if age &gt;= 18:
    print('adult')
elif age &gt;= 6:
    print('teenager')
else:
    print('kid')


elif是else
 if的缩写，完全可以有多个elif，所以if语句的完整形式就是：
if &lt;条件判断1&gt;:
    &lt;执行1&gt;
elif &lt;条件判断2&gt;:
    &lt;执行2&gt;
elif &lt;条件判断3&gt;:
    &lt;执行3&gt;
else:
    &lt;执行4&gt;


if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else，所以，请测试并解释为什么下面的程序打印的是teenager：
age = 20
if age &gt;= 6:
    print('teenager')
elif age &gt;= 18:
    print('adult')
else:
    print('kid')


if判断条件还可以简写，比如写：
if x:
    print('True')


只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。

再议 input

最后看一个有问题的条件判断。很多同学会用input()读取用户的输入，这样可以自己输入，程序运行得更有意思：
birth = input('birth: ')
if birth &lt; 2000:
    print('00前')
else:
    print('00后')


输入1982，结果报错：
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: str() &gt; int()


这是因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情：
s = input('birth: ')
birth = int(s)
if birth &lt; 2000:
    print('00前')
else:
    print('00后')


再次运行，就可以得到正确地结果。但是，如果输入abc呢？又会得到一个错误信息：
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: invalid literal for int() with base 10: 'abc'


原来int()函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。

如何检查并捕获程序运行期的错误呢？后面的错误和调试会讲到。

小结

条件判断可以让计算机自己做选择，Python的if...elif...else很灵活。


list

Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。

比如，列出班里所有同学的名字，就可以用一个list表示：
&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']
&gt;&gt;&gt; classmates
['Michael', 'Bob', 'Tracy']


变量classmates就是一个list。用len()函数可以获得list元素的个数：
&gt;&gt;&gt; len(classmates)
3


用索引来访问list中每一个位置的元素，记得索引是从0开始的：
&gt;&gt;&gt; classmates[0]
'Michael'
&gt;&gt;&gt; classmates[1]
'Bob'
&gt;&gt;&gt; classmates[2]
'Tracy'
&gt;&gt;&gt; classmates[3]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: list index out of range


当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates)
 - 1。

如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：
&gt;&gt;&gt; classmates[-1]
'Tracy'


以此类推，可以获取倒数第2个、倒数第3个：
&gt;&gt;&gt; classmates[-2]
'Bob'
&gt;&gt;&gt; classmates[-3]
'Michael'
&gt;&gt;&gt; classmates[-4]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: list index out of range


当然，倒数第4个就越界了。

list是一个可变的有序表，所以，可以往list中追加元素到末尾：
&gt;&gt;&gt; classmates.append('Adam')
&gt;&gt;&gt; classmates
['Michael', 'Bob', 'Tracy', 'Adam']


也可以把元素插入到指定的位置，比如索引号为1的位置：
&gt;&gt;&gt; classmates.insert(1, 'Jack')
&gt;&gt;&gt; classmates
['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']


要删除list末尾的元素，用pop()方法：
&gt;&gt;&gt; classmates.pop()
'Adam'
&gt;&gt;&gt; classmates
['Michael', 'Jack', 'Bob', 'Tracy']


要删除指定位置的元素，用pop(i)方法，其中i是索引位置：
&gt;&gt;&gt; classmates.pop(1)
'Jack'
&gt;&gt;&gt; classmates
['Michael', 'Bob', 'Tracy']


要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：
&gt;&gt;&gt; classmates[1] = 'Sarah'
&gt;&gt;&gt; classmates
['Michael', 'Sarah', 'Tracy']


list里面的元素的数据类型也可以不同，比如：
&gt;&gt;&gt; L = ['Apple', 123, True]


list元素也可以是另一个list，比如：
&gt;&gt;&gt; s = ['python', 'java', ['asp', 'php'], 'scheme']
&gt;&gt;&gt; len(s)
4


要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：
&gt;&gt;&gt; p = ['asp', 'php']
&gt;&gt;&gt; s = ['python', 'java', p, 'scheme']


要拿到'php'可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。

如果一个list中一个元素也没有，就是一个空的list，它的长度为0：
&gt;&gt;&gt; L = []
&gt;&gt;&gt; len(L)
0


tuple

另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：
&gt;&gt;&gt; classmates = ('Michael', 'Bob', 'Tracy')


现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。

不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。

tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：
&gt;&gt;&gt; t = (1, 2)
&gt;&gt;&gt; t
(1, 2)


如果要定义一个空的tuple，可以写成()：
&gt;&gt;&gt; t = ()
&gt;&gt;&gt; t
()


但是，要定义一个只有1个元素的tuple，如果你这么定义：
&gt;&gt;&gt; t = (1)
&gt;&gt;&gt; t
1


定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。

所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：
&gt;&gt;&gt; t = (1,)
&gt;&gt;&gt; t
(1,)


Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。

最后来看一个“可变的”tuple：
&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])
&gt;&gt;&gt; t[2][0] = 'X'
&gt;&gt;&gt; t[2][1] = 'Y'
&gt;&gt;&gt; t
('a', 'b', ['X', 'Y'])


这个tuple定义的时候有3个元素，分别是'a'，'b'和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？

别急，我们先看看定义的时候tuple包含的3个元素：



当我们把list的元素'A'和'B'修改为'X'和'Y'后，tuple变为：



表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！

理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。

小结

list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。


字符编码

我们已经讲过了，字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。

因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。

由于计算机是美国人发明的，因此，最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。

但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。

你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。



因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。

Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。

现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。

字母A用ASCII编码是十进制的65，二进制的01000001；

字符0用ASCII编码是十进制的48，二进制的00110000，注意字符'0'和整数0是不同的；

汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110
 00101101。

你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000
 01000001。

新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。

所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：




字符

ASCII

Unicode

UTF-8



A

01000001

00000000 01000001

01000001



中

x

01001110 00101101

11100100 10111000 10101101




从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。

搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：

在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。

用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：



浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：



所以你看到很多网页的源码上会有类似&lt;meta charset="UTF-8" /&gt;的信息，表示该网页正是用的UTF-8编码。

Python的字符串

搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。

在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：
&gt;&gt;&gt; print('包含中文的str')
包含中文的str


对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：
&gt;&gt;&gt; ord('A')
65
&gt;&gt;&gt; ord('中')
20013
&gt;&gt;&gt; chr(66)
'B'
&gt;&gt;&gt; chr(25991)
'文'


如果知道字符的整数编码，还可以用十六进制这么写str：
&gt;&gt;&gt; '\u4e2d\u6587'
'中文'


两种写法完全是等价的。

由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。

Python对bytes类型的数据用带b前缀的单引号或双引号表示：
x = b'ABC'


要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。

以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：
&gt;&gt;&gt; 'ABC'.encode('ascii')
b'ABC'
&gt;&gt;&gt; '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'
&gt;&gt;&gt; '中文'.encode('ascii')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)


纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。

在bytes中，无法显示为ASCII字符的字节，用\x##显示。

反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：
&gt;&gt;&gt; b'ABC'.decode('ascii')
'ABC'
&gt;&gt;&gt; b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'


要计算str包含多少个字符，可以用len()函数：
&gt;&gt;&gt; len('ABC')
3
&gt;&gt;&gt; len('中文')
2


len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：
&gt;&gt;&gt; len(b'ABC')
3
&gt;&gt;&gt; len(b'\xe4\xb8\xad\xe6\x96\x87')
6
&gt;&gt;&gt; len('中文'.encode('utf-8'))
6


可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。

在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。

由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：
#!/usr/bin/env python3
# -*- coding: utf-8 -*-


第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；

第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。

申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without
 BOM编码：



如果.py文件本身使用UTF-8编码，并且也申明了#
 -*- coding: utf-8 -*-，打开命令提示符测试就可以正常显示中文：



格式化

最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似'亲爱的xxx你好！你xx月的话费是xx，余额是xx'之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。



在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：
&gt;&gt;&gt; 'Hello, %s' % 'world'
'Hello, world'
&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)
'Hi, Michael, you have $1000000.'


你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。

常见的占位符有：




%d

整数



%f

浮点数



%s

字符串



%x

十六进制整数




其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：
&gt;&gt;&gt; '%2d-%02d' % (3, 1)
' 3-01'
&gt;&gt;&gt; '%.2f' % 3.1415926
'3.14'


如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：
&gt;&gt;&gt; 'Age: %s. Gender: %s' % (25, True)
'Age: 25. Gender: True'


有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：
&gt;&gt;&gt; 'growth rate: %d %%' % 7
'growth rate: 7 %'

小结

Python 3的字符串使用Unicode，直接支持多语言。

str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式，比如把Unicode编码成GB2312：
&gt;&gt;&gt; '中文'.encode('gb2312')
'\xd6\xd0\xce\xc4'


但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。

格式化字符串的时候，可以用Python的交互式命令行测试，方便快捷。


数据类型

计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：

整数

Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。

计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。

浮点数

浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。

整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。

字符串

字符串是以单引号'或双引号"括起来的任意文本，比如'abc'，"xyz"等等。请注意，''或""本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。如果'本身也是一个字符，那就可以用""括起来，比如"I'm
 OK"包含的字符是I，'，m，空格，O，K这6个字符。

如果字符串内部既包含'又包含"怎么办？可以用转义字符\来标识，比如：
'I\'m \"OK\"!'


表示的字符串内容是：
I'm "OK"!


转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：
&gt;&gt;&gt; print('I\'m ok.')
I'm ok.
&gt;&gt;&gt; print('I\'m learning\nPython.')
I'm learning
Python.
&gt;&gt;&gt; print('\\\n\\')
\
\


如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r''表示''内部的字符串默认不转义，可以自己试试：
&gt;&gt;&gt; print('\\\t\\')
\       \
&gt;&gt;&gt; print(r'\\\t\\')
\\\t\\


如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容，可以自己试试：
&gt;&gt;&gt; print('''line1
... line2
... line3''')
line1
line2
line3


上面是在交互式命令行内输入，注意在输入多行内容时，提示符由&gt;&gt;&gt;变为...，提示你可以接着上一行输入。如果写成程序，就是：
print('''line1
line2
line3''')


多行字符串'''...'''还可以在前面加上r使用，请自行测试。

布尔值

布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：
&gt;&gt;&gt; True
True
&gt;&gt;&gt; False
False
&gt;&gt;&gt; 3 &gt; 2
True
&gt;&gt;&gt; 3 &gt; 5
False


布尔值可以用and、or和not运算。

and运算是与运算，只有所有都为True，and运算结果才是True：
&gt;&gt;&gt; True and True
True
&gt;&gt;&gt; True and False
False
&gt;&gt;&gt; False and False
False
&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1
True


or运算是或运算，只要其中有一个为True，or运算结果就是True：
&gt;&gt;&gt; True or True
True
&gt;&gt;&gt; True or False
True
&gt;&gt;&gt; False or False
False
&gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3
True


not运算是非运算，它是一个单目运算符，把True变成False，False变成True：
&gt;&gt;&gt; not True
False
&gt;&gt;&gt; not False
True
&gt;&gt;&gt; not 1 &gt; 2
True


布尔值经常用在条件判断中，比如：
if age &gt;= 18:
    print('adult')
else:
    print('teenager')


空值

空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。

此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。

变量

变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。

变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：
a = 1


变量a是一个整数。
t_007 = 'T007'


变量t_007是一个字符串。
Answer = True


变量Answer是一个布尔值True。

在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：
a = 123 # a是整数
print(a)
a = 'ABC' # a变为字符串
print(a)


这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：
int a = 123; // a是整数类型变量
a = "ABC"; // 错误：不能把字符串赋给整型变量


和静态语言相比，动态语言更灵活，就是这个原因。

请不要把赋值语句的等号等同于数学的等号。比如下面的代码：
x = 10
x = x + 2


如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x
 + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。

最后，理解变量在计算机内存中的表示也非常重要。当我们写：
a = 'ABC'


时，Python解释器干了两件事情：



在内存中创建了一个'ABC'的字符串；


在内存中创建了一个名为a的变量，并把它指向'ABC'。


也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：
a = 'ABC'
b = a
a = 'XYZ'
print(b)


最后一行打印出变量b的内容到底是'ABC'呢还是'XYZ'？如果从数学意义上理解，就会错误地得出b和a相同，也应该是'XYZ'，但实际上b的值是'ABC'，让我们一行一行地执行代码，就可以看到到底发生了什么事：

执行a = 'ABC'，解释器创建了字符串'ABC'和变量a，并把a指向'ABC'：



执行b = a，解释器创建了变量b，并把b指向a指向的字符串'ABC'：



执行a = 'XYZ'，解释器创建了字符串'XYZ'，并把a的指向改为'XYZ'，但b并没有更改：



所以，最后打印变量b的结果自然是'ABC'了。

常量

所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：
PI = 3.14159265359


但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。

最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：
&gt;&gt;&gt; 10 / 3
3.3333333333333335


/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：
&gt;&gt;&gt; 9 / 3
3.0


还有一种除法是//，称为地板除，两个整数的除法仍然是整数：
&gt;&gt;&gt; 10 // 3
3


你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。

因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：
&gt;&gt;&gt; 10 % 3
1


无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。

小结

Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。

注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。

Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。


Python是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码，然后执行。Python也不例外。

Python的语法比较简单，采用缩进方式，写出来的代码就像下面的样子：
# print absolute value of an integer:
a = 100
if a &gt;= 0:
    print(a)
else:
    print(-a)


以#开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块。

缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的管理，应该始终坚持使用4个空格的缩进。

缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若干函数，从而得到缩进较少的代码。

缩进的坏处就是“复制－粘贴”功能失效了，这是最坑爹的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像格式化Java代码那样格式化Python代码。

最后，请务必注意，Python程序是大小写敏感的，如果写错了大小写，程序会报错。

小结

Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进。

在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。


输出

用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。比如输出'hello,
 world'，用代码实现如下：
&gt;&gt;&gt; print('hello, world')


print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：
&gt;&gt;&gt; print('The quick brown fox', 'jumps over', 'the lazy dog')
The quick brown fox jumps over the lazy dog


print()会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：



print()也可以打印整数，或者计算结果：
&gt;&gt;&gt; print(300)
300
&gt;&gt;&gt; print(100 + 200)
300


因此，我们可以把计算100 + 200的结果打印得更漂亮一点：
&gt;&gt;&gt; print('100 + 200 =', 100 + 200)
100 + 200 = 300


注意，对于100 + 200，Python解释器自动计算出结果300，但是，'100
 + 200 ='是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。

输入

现在，你已经可以用print()输出你想要的结果了。但是，如果要让用户从电脑输入一些字符怎么办？Python提供了一个input()，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：
&gt;&gt;&gt; name = input()
Michael


当你输入name = input()并按下回车后，Python交互式命令行就在等待你的输入了。这时，你可以输入任意字符，然后按回车后完成输入。

输入完成后，不会有任何提示，Python交互式命令行又回到&gt;&gt;&gt;状态了。那我们刚才输入的内容到哪去了？答案是存放到name变量里了。可以直接输入name查看变量内容：
&gt;&gt;&gt; name
'Michael'


什么是变量？请回忆初中数学所学的代数基础知识：

设正方形的边长为a，则正方形的面积为a
 x a。把边长a看做一个变量，我们就可以根据a的值计算正方形的面积，比如：

若a=2，则面积为a x a = 2 x 2 = 4；

若a=3.5，则面积为a x a = 3.5 x 3.5 = 12.25。

在计算机程序中，变量不仅可以为整数或浮点数，还可以是字符串，因此，name作为一个变量就是一个字符串。

要打印出name变量的内容，除了直接写name然后按回车外，还可以用print()函数：
&gt;&gt;&gt; print(name)
Michael


有了输入和输出，我们就可以把上次打印'hello, world'的程序改成有点意义的程序了：
name = input()
print('hello,', name)


运行上面的程序，第一行代码会让用户输入任意字符作为自己的名字，然后存入name变量中；第二行代码会根据用户的名字向用户说hello，比如输入Michael：
C:\Workspace&gt; python hello.py
Michael
hello, Michael


但是程序运行的时候，没有任何提示信息告诉用户：“嘿，赶紧输入你的名字”，这样显得很不友好。幸好，input()可以让你显示一个字符串来提示用户，于是我们把代码改成：
name = input('please enter your name: ')
print('hello,', name)


再次运行这个程序，你会发现，程序一运行，会首先打印出please enter your name:，这样，用户就可以根据提示，输入名字后，得到hello,
 xxx的输出：
C:\Workspace&gt; python hello.py
please enter your name: Michael
hello, Michael


每次运行该程序，根据用户输入的不同，输出结果也会不同。

在命令行下，输入和输出就是这么简单。

小结

任何计算机程序都是为了执行一个特定的任务，有了输入，用户才能告诉计算机程序所需的信息，有了输出，程序运行后才能告诉用户任务的结果。

输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。

input()和print()是在命令行下面最基本的输入和输出，但是，用户也可以通过其他更高级的图形界面完成输入和输出，比如，在网页上的一个文本框输入自己的名字，点击“确定”后在网页上看到输出信息。


在Python的交互式命令行写程序，好处是一下就能得到结果，坏处是没法保存，下次还想运行的时候，还得再敲一遍。

所以，实际开发的时候，我们总是使用一个文本编辑器来写代码，写完了，保存为一个文件，这样，程序就可以反复运行了。

现在，我们就把上次的'hello, world'程序用文本编辑器写出来，保存下来。

那么问题来了：文本编辑器到底哪家强？

推荐两款文本编辑器：

一个是Sublime Text，免费使用，但是不付费会弹出提示框：



一个是Notepad++，免费使用，有中文界面：



请注意，用哪个都行，但是绝对不能用Word和Windows自带的记事本。Word保存的不是纯文本文件，而记事本会自作聪明地在文件开始的地方加上几个特殊字符（UTF-8 BOM），结果会导致程序运行出现莫名其妙的错误。

安装好文本编辑器后，输入以下代码：
print('hello, world')


注意print前面不要有任何空格。然后，选择一个目录，例如C:\work，把文件保存为hello.py，就可以打开命令行窗口，把当前目录切换到hello.py所在目录，就可以运行这个程序了：
C:\work&gt;python hello.py
hello, world


也可以保存为别的名字，比如first.py，但是必须要以.py结尾，其他的都不行。此外，文件名只能是英文字母、数字和下划线的组合。

如果当前目录下没有hello.py这个文件，运行python
 hello.py就会报错：
C:\Users\IEUser&gt;python hello.py
python: can't open file 'hello.py': [Errno 2] No such file or directory


报错的意思就是，无法打开hello.py这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。如果hello.py存放在另外一个目录下，要首先用cd命令切换当前目录。

直接运行py文件

有同学问，能不能像.exe文件那样直接运行.py文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在.py文件的第一行加上一个特殊的注释：
#!/usr/bin/env python3

print('hello, world')


然后，通过命令给hello.py以执行权限：
$ chmod a+x hello.py


就可以直接运行hello.py了，比如在Mac下运行：



小结

用文本编辑器写Python程序，然后保存为后缀为.py的文件，就可以用Python直接运行这个程序了。

Python的交互模式和直接运行.py文件有什么区别呢？

直接输入python进入交互模式，相当于启动了Python解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。

直接运行.py文件相当于启动了Python解释器，然后一次性把.py文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。

用Python开发程序，完全可以一边在文本编辑器里写代码，一边开一个交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！前提是得有个27'的超大显示器！


现在，了解了如何启动和退出Python的交互式环境，我们就可以正式开始编写Python代码了。

在写代码之前，请千万不要用“复制”-“粘贴”把代码从页面粘贴到你自己的电脑上。写程序也讲究一个感觉，你需要一个字母一个字母地把代码自己敲进去，在敲代码的过程中，初学者经常会敲错代码，所以，你需要仔细地检查、对照，才能以最快的速度掌握如何写程序。



在交互式环境的提示符&gt;&gt;&gt;下，直接输入代码，按回车，就可以立刻得到代码执行结果。现在，试试输入100+200，看看计算结果是不是300：
&gt;&gt;&gt; 100+200
300


很简单吧，任何有效的数学计算都可以算出来。

如果要让Python打印出指定的文字，可以用print()函数，然后把希望打印的文字用单引号或者双引号括起来，但不能混用单引号和双引号：
&gt;&gt;&gt; print('hello, world')
hello, world


这种用单引号或者双引号括起来的文本在程序中叫字符串，今后我们还会经常遇到。

最后，用exit()退出Python，我们的第一个Python程序完成！唯一的缺憾是没有保存下来，下次运行时还要再输入一遍代码。

命令行模式和Python交互模式

请注意区分命令行模式和Python交互模式。

看到类似C:\&gt;是在Windows提供的命令行模式：



在命令行模式下，可以执行python进入Python交互式环境，也可以执行python
 hello.py运行一个.py文件。

看到&gt;&gt;&gt;是在Python交互式环境下：



在Python交互式环境下，只能输入Python代码并立刻执行。

此外，在命令行模式运行.py文件和在Python交互式环境下直接运行Python代码有所不同。Python交互式环境会把每一行Python代码的结果自动打印出来，但是，直接运行Python代码却不会。

例如，在Python交互式环境下，输入：
&gt;&gt;&gt; 100 + 200 + 300
600


直接可以看到结果600。

但是，写一个calc.py的文件，内容如下：
100 + 200 + 300


然后在命令行模式下执行：
C:\work&gt;python calc.py


发现什么输出都没有。

这是正常的。想要输出结果，必须自己用print()打印出来。把calc.py改造一下：
print(100 + 200 + 300)


再执行，就可以看到结果：
C:\work&gt;python calc.py
600


小结

在Python交互式命令行下，可以直接输入代码，然后执行，并立刻得到结果。


当我们编写Python代码时，我们得到的是一个包含Python代码的以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。

由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。

CPython

当我们从Python官方网站下载并安装好Python 3.5后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。

CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。

IPython

IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。

CPython用&gt;&gt;&gt;作为提示符，而IPython用In
 [序号]:作为提示符。

PyPy

PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。

绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。

Jython

Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。

IronPython

IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。

小结

Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。

本教程的所有代码只确保在CPython 3.5版本下运行。请务必在本地安装CPython（也就是从Python官方网站下载的安装程序）。


因为Python是跨平台的，它可以运行在Windows、Mac和各种Linux/Unix系统上。在Windows上写Python程序，放到Linux上也是能够运行的。

要开始学习Python编程，首先就得把Python安装到你的电脑里。安装后，你会得到Python解释器（就是负责运行Python程序的），一个命令行交互环境，还有一个简单的集成开发环境。

安装Python 3.5

目前，Python有两个版本，一个是2.x版，一个是3.x版，这两个版本是不兼容的。由于3.x版越来越普及，我们的教程将以最新的Python 3.5版本为基础。请确保你的电脑上安装的Python版本是最新的3.5.x，这样，你才能无痛学习这个教程。

在Mac上安装Python

如果你正在使用Mac，系统是OS X 10.8~10.10，那么系统自带的Python版本是2.7。要安装最新的Python 3.5，有两个方法：

方法一：从Python官网下载Python 3.5的安装程序（网速慢的同学请移步国内镜像），双击运行并安装；

方法二：如果安装了Homebrew，直接通过命令brew install python3安装即可。

在Linux上安装Python

如果你正在使用Linux，那我可以假定你有Linux系统管理经验，自行安装Python 3应该没有问题，否则，请换回Windows系统。

对于大量的目前仍在使用Windows的同学，如果短期内没有打算换Mac，就可以继续阅读以下内容。

在Windows上安装Python

首先，根据你的Windows版本（64位还是32位）从Python的官方网站下载Python 3.5对应的64位安装程序或32位安装程序（网速慢的同学请移步国内镜像），然后，运行下载的EXE安装包：



特别要注意勾上Add Python 3.5 to PATH，然后点“Install Now”即可完成安装。

运行Python

安装成功后，打开命令提示符窗口，敲入python后，会出现两种情况：

情况一：



看到上面的画面，就说明Python安装成功！

你看到提示符&gt;&gt;&gt;就表示我们已经在Python交互式环境中了，可以输入任何Python代码，回车后会立刻得到执行结果。现在，输入exit()并回车，就可以退出Python交互式环境（直接关掉命令行窗口也可以）。

情况二：得到一个错误：
‘python’ 不是内部或外部命令，也不是可运行的程序或批处理文件。




这是因为Windows会根据一个Path的环境变量设定的路径去查找python.exe，如果没找到，就会报错。如果在安装时漏掉了勾选Add
 Python 3.5 to PATH，那就要手动把python.exe所在的路径添加到Path中。

如果你不知道怎么修改环境变量，建议把Python安装程序重新运行一遍，务必记得勾上Add Python 3.5 to PATH。

小结

学会如何把Python安装到计算机中，并且熟练打开和退出Python交互式环境。

在Windows上运行Python时，请先启动命令行，然后运行python。

在Mac和Linux上运行Python时，请打开终端，然后运行python3。


一些术语的字面意义翻译如下，由于这个工具的名字叫Storm，这些术语一律按照气象名词解释

spout 龙卷，读取原始数据为bolt提供数据bolt 雷电，从spout或其它bolt接收数据，并处理数据，处理结果可作为其它bolt的数据源或最终结果nimbus 雨云，主节点的守护进程，负责为工作节点分发任务。

下面的术语跟气象就没有关系了

topology 拓扑结构，Storm的一个任务单元define field(s) 定义域，由spout或bolt提供，被bolt接收

基础知识

Storm是一个分布式的，可靠的，容错的数据流处理系统。它会把工作任务委托给不同类型的组件，每个组件负责处理一项简单特定的任务。Storm集群的输入流由一个被称作spout的组件管理，spout把数据传递给bolt， bolt要么把数据保存到某种存储器，要么把数据传递给其它的bolt。你可以想象一下，一个Storm集群就是在一连串的bolt之间转换spout传过来的数据。

这里用一个简单的例子来说明这个概念。昨晚我在新闻节目里看到主持人在谈论政治人物和他们对于各种政治话题的立场。他们一直重复着不同的名字，而我开始考虑这些名字是否被提到了相同的次数，以及不同次数之间的偏差。

想像播音员读的字幕作为你的数据输入流。你可以用一个spout读取一个文件（或者socket，通过HTTP，或者别的方法）。文本行被spout传给一个bolt，再被bolt按单词切割。单词流又被传给另一个bolt，在这里每个单词与一张政治人名列表比较。每遇到一个匹配的名字，第二个bolt为这个名字在数据库的计数加1。你可以随时查询数据库查看结果， 而且这些计数是随着数据到达实时更新的。所有组件（spouts和bolts）及它们之间的关系请参考拓扑图1-1



现在想象一下，很容易在整个Storm集群定义每个bolt 和spout的并行性级别，因此你可以无限的扩展你的拓扑结构。很神奇，是吗？尽管这是个简单例子，你也可以看到Storm的强大。

有哪些典型的Storm应用案例？

数据处理流

正如上例所展示的，不像其它的流处理系统，Storm不需要中间队列。

连续计算

连续发送数据到客户端，使它们能够实时更新并显示结果，如网站指标。

分布式远程过程调用

频繁的CPU密集型操作并行化。

Storm组件

对于一个Storm集群，一个连续运行的主节点组织若干节点工作。

在Storm集群中，有两类节点：主节点master node和工作节点worker nodes。主节点运行着一个叫做Nimbus的守护进程。这个守护进程负责在集群中分发代码，为工作节点分配任务，并监控故障。Supervisor守护进程作为拓扑的一部分运行在工作节点上。一个Storm拓扑结构在不同的机器上运行着众多的工作节点。

因为Storm在Zookeeper或本地磁盘上维持所有的集群状态，守护进程可以是无状态的而且失效或重启时不会影响整个系统的健康（见图1-2）



在系统底层，Storm使用了zeromq(0mq, zeromq(http://www.zeromq.org))。这是一种先进的，可嵌入的网络通讯库，它提供的绝妙功能使Storm成为可能。下面列出一些zeromq的特性。

一个并发架构的Socket库对于集群产品和超级计算，比TCP要快可通过inproc（进程内）, IPC（进程间）, TCP和multicast(多播协议)通信异步I / O的可扩展的多核消息传递应用程序利用扇出(fanout), 发布订阅（PUB-SUB）,管道（pipeline）, 请求应答（REQ-REP），等方式实现N-N连接

NOTE: Storm只用了push/pull sockets

Storm的特性

在所有这些设计思想与决策中，有一些非常棒的特性成就了独一无二的Storm。

简化编程    如果你曾试着从零开始实现实时处理，你应该明白这是一件多么痛苦的事情。使用Storm，复杂性被大大降低了。使用一门基于JVM的语言开发会更容易，但是你可以借助一个小的中间件，在Storm上使用任何语言开发。有现成的中间件可供选择，当然也可以自己开发中间件。容错         Storm集群会关注工作节点状态，如果宕机了必要的时候会重新分配任务。可扩展    所有你需要为扩展集群所做的工作就是增加机器。Storm会在新机器就绪时向它们分配任务。可靠的    所有消息都可保证至少处理一次。如果出错了，消息可能处理不只一次，不过你永远不会丢失消息。快速        速度是驱动Storm设计的一个关键因素事务性   You can get exactly once messaging semantics for pretty much any computation.你可以为几乎任何计算得到恰好一次消息语义。


请看下文详解。use db_CSharp
go
 select *,
 备注=case
 when Grade&gt;=90 then '成绩优秀'
 when Grade&lt;90 and Grade&gt;=80 then '成绩良好'
 when Grade&lt;80 and Grade&gt;=70 then '成绩及格'
 else '不及格'
 end
 from tb_Grade


如果只是执行一条语句，有没有GO都一样

如果多条语句之间用GO分隔开就不一样了

每个被GO分隔的语句都是一个单独的事务，一个语句执行失败不会影响其它语句执行。

例如：

首先同时执行下边的语句
select * from sysobjects where id=a
select getdate()

你会发现会报错，并且不会显示任何结果集

而你再执行
select * from sysobjects where id=a
go
select getdate()
go

你会发现尽管同样会报错，但结果集中包含select getdate()的结果。

ps:SQL SERVER 中 GO 的用法

用信号通知 Microsoft? SQL Server? 实用工具一批 Transact-SQL 语句的结束。
GO 不是 Transact-SQL 语句；而是可为 osql 和 isql 实用工具及 SQL Server 查询分析器识别的命令。


如果你的SQL过长的时候，就要写GO，或者有一些语句，它只能是第一句操作的，在之前你也得写 GO ，GO的意思 是 分批处理语句 有加这个 GO ，就执行GO 行的代码，执行后再执行接下来的代码……

像这样的情况下就要用到GO ，分批处理数据……
use master
go
 
if exists (select * from sysdatabases where name = 'kejianDB')
drop database kejianDB
go
 
create database kejianDB
go
 
use kejianDB
go
 
 
--(行业表)
create table Trade
(
tra_Id int primary key identity(1,1) not null, --行业ID (主键、自增长)
tra_Name varchar(50) not null --行业名称
)
go以上就是本文的全部叙述。


题目：n个数字（0,1,…,n-1）形成一个圆圈，从数字0开始，每次从这个圆圈中删除第m个数字（第一个为当前数字本身，第二个为当前数字的下一个数字）。当一个数字删除后，从被删除数字的下一个继续删除第m个数字。求出在这个圆圈中剩下的最后一个数字。

分析：本题就是有名的约瑟夫环问题。既然题目有一个数字圆圈，很自然的想法是我们用一个数据结构来模拟这个圆圈。在常用的数据结构中，我们很容易想到用环形列表。我们可以创建一个总共有m个数字的环形列表，然后每次从这个列表中删除第m个元素。



我们试着从数学上分析出一些规律。首先定义最初的n个数字（0,1,…,n-1）中最后剩下的数字是关于n和m的方程为f(n,m)。

在这n个数字中，第一个被删除的数字是(m-1)%n，为简单起见记为k。那么删除k之后的剩下n-1的数字为0,1,…,k-1,k+1,…,n-1，并且下一个开始计数的数字是k+1。相当于在剩下的序列中，k+1排到最前面，从而形成序列k+1,…,n-1,0,…k-1。该序列最后剩下的数字也应该是关于n和m的函数。由于这个序列的规律和前面最初的序列不一样（最初的序列是从0开始的连续序列），因此该函数不同于前面函数，记为f’(n-1,m)。最初序列最后剩下的数字f(n,m)一定是剩下序列的最后剩下数字f’(n-1,m)，所以f(n,m)=f’(n-1,m)。

接下来我们把剩下的的这n-1个数字的序列k+1,…,n-1,0,…k-1作一个映射，映射的结果是形成一个从0到n-2的序列：

k+1    -&gt;    0
k+2    -&gt;    1
…
n-1    -&gt;    n-k-2
0   -&gt;    n-k-1
…
k-1   -&gt;   n-2

把映射定义为p，则p(x)= (x-k-1)%n，即如果映射前的数字是x，则映射后的数字是(x-k-1)%n。对应的逆映射是p-1(x)=(x+k+1)%n。

由于映射之后的序列和最初的序列有同样的形式，都是从0开始的连续序列，因此仍然可以用函数f来表示，记为f(n-1,m)。根据我们的映射规则，映射之前的序列最后剩下的数字f’(n-1,m)= p-1 [f(n-1,m)]=[f(n-1,m)+k+1]%n。把k=(m-1)%n代入得到f(n,m)=f’(n-1,m)=[f(n-1,m)+m]%n。

经过上面复杂的分析，我们终于找到一个递归的公式。要得到n个数字的序列的最后剩下的数字，只需要得到n-1个数字的序列的最后剩下的数字，并可以依此类推。当n=1时，也就是序列中开始只有一个数字0，那么很显然最后剩下的数字就是0。我们把这种关系表示为：

         0                  n=1
f(n,m)={
         [f(n-1,m)+m]%n     n&gt;1

尽管得到这个公式的分析过程非常复杂，但它用递归或者循环都很容易实现。最重要的是，这是一种时间复杂度为O(n)，空间复杂度为O(1)的方法，因此无论在时间上还是空间上都优于前面的思路。
参考代码：

/**
     * 
     * @Title: 		 lastRemaining   
     * @Description: n integers(0,1,...,n-1) form a circle.Remove the mth from the circle 
     *               at every time.Find the last number remaining  
     * @param n the number of integers in the circle initially
     * @param m remove the mth number at every time
     * 
     * the result will be :the last number remaining when the input is valid,otherwise -1
     */
    private static int lastRemaining(int n, int m) {
        //invalid input
        if (n &lt;= 0 || m &lt;= 0) {
            return -1;
        }

        //if there are only one integer in the circle initially,of course the last remaining one is 0
        int lastInteger = 0;

        //find the last remaining one in the circle with n integers
        for (int i = 2; i &lt;= n; i++) {
            lastInteger = (lastInteger + m) % i;
        }

        return lastInteger;
    }




一：Redis是什么？

　　这个我想怎么总结呢，突然发现再好的解释也没有redis官网解释的好，它的解释已经达到超宇宙的级别了。。。不信你可以看看。



 

人家也说了，redis是个内存存储的数据结构服务器，这个听起来有多么牛逼啊。。。。一说到数据结构，第一反映就会想到那些dictionary,hashset,list,

SortDictionary等等。。。然后你也会想到这些数据结构有如下一些缺点。

比如：

1.  dictionary不能在多台机器中共享内存，除非你用wcf把dictionary单独包装起来作为一个服务。

2.  不能序列化到硬盘，除非你自己写很多的序列化硬盘代码，而且还要保证数据不丢失。

 

现在可以明确的告诉你，这些对redis来说都不是问题，因为它就是为解决这些问题而生的。。。 什么list，hashset，dictionary。。。redis里面都有，实际

用途上面也说了redis可以用做database，cache and messagebroker。。。

 

二：如何下载

    前面都是一些大道理，我们只要抓住几个关键字就可以了，说的再好也没用，怎么玩才是最重要的，具体怎么下

载这，我就不详细说了。

 

1. 使用命令

　　　 其实reids官网上已经详细教我们怎么下载，编译和运行了，我们按照步骤一步一步来就好了。



 

前奏的几个步骤之后，你可以清楚的看到redis的安装包，解压包， 完了之后你再执行一下reids-server来开启一下服务端，你会欣喜的看到，redis跑起来啦，很easy的事情嘛~~~





 

2. 如何交互

　  redis官网也说了，使用redis-cli来进行交互，接下来我们试试就好咯。。。





 

好了，一切都是顺意民意，第一篇大概就这么说了，我想到现在为止，你应该知道怎么下载，安装和简单使用了，下一篇我们开始使用各种命令来玩转它。

一． JavaEE的架构
二． JavaEE的核心技术简介
三． JavaEE平台中的角色
四． 当前流行的JavaEE平台
五．  JavaEE的应用
 
一．JavaEE架构：

JavaEE的运行环境定义了4种类型的应用组件：
l       Applet客户端
l       Application客户端
l       Web组件
l       EJB组件
 
 
二．JavaEE核心技术：13种
 
   EJB、CORBA、RMI、JSP、Java Servlet、JavaBean、JDBC、XML、……

EJB — JavaEE的基石：
l       EJB (Enterprise JavaBeans) ：
           一个Java服务器端组件开发的规范，定义了一个用来开发面向对象分布式应用组件的标准方法，软件厂商根据它来实现EJB服务器。
           Java程序员可以将一些EJB组件组合起来，从而方便、快捷地建构起分布式应用程序。EJB规范在简化分布式应用程序开发复杂性方面也做了大量的工作，EJB程序员不必太担心事务处理、多线程、资源管理等方面的问题，可以专注于支持应用所需的商业逻辑，而不用担心周围框架的实现问题。使用EJB可以使整个程序分块明确，并且EJB可以使用其它EJB或JDBC等服务，从而增强了分布式应用程序的可扩展性和性能；另外，EJB的使用增强了整个系统程序的可靠性、可管理性和可移植性。


l       EJB组件
     EJB分为三种：会话EJB、实体EJB和消息驱动EJB
 
l       EJB容器
      是EJB组件的运行环境，为部署的EJB组件提供各种服务（事务、安全、远程客户端的网络发布、资源管理等）。容器厂商也可以在容器或服务器中提供额外服务的接口。
 
l       EJB服务器
      管理EJB容器的高端进程或应用程序，并提供对系统服务的访问。EJB服务器也可以提供厂商自己的特性，如优化的数据库访问接口，对其他服务（如CORBA服务）的访问等。

CORBA体系结构：核心－ORB



CORBA技术：
l       CORBA（Common Object Request Broker Architecture）是一个开发分布式对象系统标准（规范），它独立于平台，也独立于语言。由OMG制定。
l       在这个体系结构中，一个对象可以被本机上的客户或远程客户通过方法激活来访问。客户（一个对象或应用）无须知道被调用对象（称为服务对象）的运行环境，也无须知道实现这个对象的编程语言，客户只要知道服务对象的逻辑地址和提供的接口。
l       这种互操作性的关键是IDL（Interface Definition Language、接口定义语言），IDL说明对象接口中的方法，这些方法可以被其它对象（或应用）激活。
 
RMI技术：
l       RMI(Remote Method Invoke)是一种被EJB使用的更底层的协议，正如其名字所表示的那样，RMI协议调用远程对象上方法，使用序列化方式在客户端和服务器端的对象之间传递数据。


RMI和CORBA相比：
l       两者的关键差别在于语言环境，Java RMI是一个分布式对象计算的纯Java解决方案(如，在Java RMI中，对象的接口用Java定义，而不是用IDL)；
l       其次，CORBA没有定义安全服务，而Java RMI继承了Java的安全性；
l       再者，CORBA有不同的实现，不同的独立软件开发商的不同实现均有独特性，这使得在不同平台上的匹配比较困难，而且不是所有CORBA产品开发商都支持所有平台，而几乎所有平台都支持Java虚拟机，因此Java RMI具有更高的可移植性。如果客户对象和服务对象都基于Java虚拟机，那么Java RMI是分布对象计算的最好选择。当然，IIOP（Internet Inter-ORB Protocol）已经提供了Java RMI和CORBA的互操作能力，而且两者的发展有互相借鉴的趋势。
 
JSP技术：
l       JSP是服务器端的脚本语言，是以Java和Servlet为基础开发而成的动态网页生成技术，它的底层实现是Java Servlet。
l       JSP(Java Server Pages)页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端所请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器。
 
l       特点：面向对象，跨平台，和Servlet一样稳定，可以使用Servlet提供的API，克服了Servlet的缺点。
l       应用：一般和JavaBeans结合使用，从而将界面表现和业务逻辑分离。


JSP和ASP的比较（一）：
相似：
 
l       都是运行于服务器端的脚本语言，两者都是动态网页生成技术。
l       这两项技术都使用HTML来决定网页的版面，都是在HTML 代码中混合某种程序代码，由语言引擎解释执行程序代码。HTML代码主要负责描述信息的显示样式，而程序代码则用来描述处理逻辑。
JSP和ASP的比较（二）：
不同：
 
l       JSP是由Sun推出的一项技术，是基于JavaServlet以及整个java体系的Web开发技术，利用这一技术可以建立先进、安全和跨平台的动态网站。ASP是MS公司推出的技术，只能在MS的平台上运行，无法实现跨平台，也无安全性保障。
l       ASP下的编程语言是 VBScript 之类的脚本语言，而JSP 使用的是Java。
l       ASP 与 JSP 还有一个更为本质的区别：两种语言引擎用完全不同的方式处理页面中嵌入的程序代码。在 ASP 下， VBScript 代码被 ASP 引擎解释执行；在 JSP 下，代码被编译成 Servlet 并由 Java 虚拟机执行，这种编译操作仅在对 JSP 页面的第一次请求时发生。
 
 
Java Servlet技术：
 
l       Servlets(＝Server ＋Applet)：是一些运行于Web服务器端的Java小程序，用来扩展Web服务器的功能。
l       Servlets用特定的Java解决方案替代了其它的Web服务器方编程模式（如：CGI，ISAPI等），因而继承了Java的所有特性(跨平台、多线程、OO)。
l       Servlets可以嵌入在不同的Java Web服务器之中，因为用来编写Servlets的Servlet API对于服务器环境和协议没有任何特殊的要求，所以Servlets具有很强的可移植性，也不像利用CGI程序等其它方式那样具有性能局限。
l       Servlets也同样使用HTTP协议与客户端进行通讯，所以有时也称Sevlets为“HTTP Servlets”。
l       Servlet是一种扩展Web服务器功能的简单而相似的技巧，而且由于它是用Java编写的，所以能够访问整个Java API库，包括用于访问企业数据库的JDBC API。
 
 
Java Servlet和JSP的比较：
l       两者都是基于Java的技术，所以都继承了Java的所有特性（跨平台、多线程、OO），都可以使用Java强大的API。
l       两者工作方式相似：JSP代码先被JSP容器转换为Servlet代码再编译为类。
l       两者在JavaEE体系结构中的工作层次相同，都负责与客户端的连接。
 
l       Servlets是一些运行于Web服务器端的Java小程序；而JSP是脚本，编写起来更简单容易。
l       Servlet主要用于从客户端接收请求信息，而JSP主要负责将服务器端信息传送到客户端。
l       使用Servlet的真正意义在于：可以将界面设计和业务逻辑设计分离。
 
 
JavaBean技术：
l       JavaBean是基于Java的组件模型，有点类似于Microsoft的COM组件。
l       在Java平台中，通过JavaBean可以无限扩充Java程序的功能，通过JavaBean的组合可以快速的生成新的应用程序。
l       对于程序员来说，最好的一点就是JavaBean可以实现代码的重复利用，另外对于程序的易维护性等等也有很重大的意义。
l       JavaBean通过Java虚拟机(Java Virtual Machine)执行，运行JavaBean最小的需求是JDK1.1或者以上的版本。
l       JavaBean传统的应用在于可视化的领域，如AWT下的应用。自从Jsp诞生后，JavaBean更多的应用在了非可视化领域，在服务器端应用方面表现出来了越来越强的生命力。
 
 
JDBC技术：
l       JDBC是一组API，定义了用来访问数据源的标准Java类库，使用这个类库可以以一种标准的方法、方便地访问数据库资源。
l       JDBC的目标是使应用程序开发人员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。
l       JDBC API为访问不同的数据库提供了一种统一的途径，象ODBC一样，JDBC对开发者屏蔽了一些细节问题，
l       JDBC对数据库的访问也具有平台无关性。
 
XML技术：
l       XML(Extensible Markup Language)是一种可以用来定义其它标记语言的语言，被用来在不同的商务过程中共享数据。
l       XML的发展和Java是相互独立的，但是它和Java具有的相同目标即平台独立性。通过将Java和XML的组合，可以得到一个完美的具有平台独立性的解决方案。
l       JavaEE平台全面支持和实施XML，这种强大的组合可使XML具备跨平台的兼容性，甚至用于对XML代码进行语法检查和调试的工具也可与平台无关。
l       因为XML可实施独立于平台的数据，而JavaEE平台则可实施独立于平台的解决方案，所以JavaEE技术和XML技术分别是企业开发的阴阳两极。XML可通过移植的方式表现数据，因此就对Java技术的可移植性构成了补充。
 
JavaEE其它核心技术：
       JNDI(Java Naming and  Directory Interface)、           
       JMAPI(Java  Management API)、
       JTS/JTA(Java Transaction Service/API)、   
       JMS( Java Messaging Service)、
       Java Security API。
 
l       JavaEE核心技术中最常用的技术：
EJB、 JSP、Java Servlet、JavaBean、JDBC、……
 
l       开发大型应用：异构、分布、数据交换
 
三.JavaEE平台中的角色
 
在JavaEE平台中规定了七种角色，这七种角色在开发JavaEE平台及JavaEE应用中承担各自的任务。
（1）JavaEE平台开发商
（2）应用组件提供者
（3）应用组装者
（4）应用发布者
（5）系统管理员
（6）工具提供者
（7）系统组件提供者
 
（1）JavaEE平台开发商
l       JavaEE平台开发者提供实现基于JavaEE规范的产品，包括运行JavaEE应用的容器、JavaEE平台API。JavaEE平台开发者必须提供JavaEE规范规定的应用组件到网络协议的映射，提供JavaEE应用的发布与管理工具。
（2）应用组件提供者
应用组件提供者开发JavaEE应用组件，包括JSP、Servlet及EJB等。
（3）应用组装者
应用组装者负责将应用组件提供者开发的JavaEE应用组件组装为JavaEE应用。
（4）应用发布者
l       应用发布者将组装好的JavaEE应用发布到JavaEE应用的容器中，配置其运行环境，并启动JavaEE应用运行。
（5）系统管理员
l       系统管理员负责配置管理整个企业或组织的网络与计算环境，其中包括运行在JavaEE平台上的JavaEE应用。
（6）工具提供者
l       工具提供者提供JavaEE平台之外的JavaEE应用开发、组装、发布及管理工具。
（7）系统组件提供者
系统组件提供者提供系统级的通用的组件，如连接企业现有ERP系统的适配器等。
 
四．当前流行的JavaEE平台
l       目前市场上已经有许多成熟的实现JavaEE规范的产品，其中有的是商业公司的产品，而有的是开放源代码的免费产品。
 
商业公司的产品
 
商业公司的产品除Interstage外，另外主要还有BEA WebLogic、IBM WebSphere、Oracle Application Server、Borland Enterprise Server、SUN iPlanet Application Server等。这些产品一般都包括一组完整的产品线，用来支持JavaEE应用从开发、组装、发布及管理的整个过程。
 
组成
（1）应用服务器
      商业公司产品中的应用服务器一般都完全支持JavaEE规范的应用服务器，除包括Servlet容器、EJB容器外，还提供WEB Services、CORBA等服务。
（2）应用集成化开发环境
商业公司的产品提供支持开发JavaEE应用的集成开发环境，可以大大提高应用开发、调试的效率。
（3）JavaEE规范之外的工具
除了在JavaEE规范中规定的部分外，商业公司的产品一般还包括提供服务器负载均衡、安全控制、开发企业门户等功能在内的工具。
 
开放源代码的产品
l       开放源代码的产品中有如Apache Tomcat及JBOSS等产品。这些产品不仅是免费的，而且能够提供很好的功能和性能，因此也有很广泛的应用。
l       （1）Apache Tomcat
    Apache Tomcat 是一个Servlet容器，它支持Servlet/JSP规范。有些商业公司的JavaEE平台产品中使用它作为自己应用服务器的Servlet容器，或者在JavaEE应用集成开发环境中作为调试应用程序的服务器。
l       （2）JBOSS
      JBOSS 是一个EJB容器，但是因为它是基于JMX微内核结构开发的，所以很容易与其它产品集成在一起使用，如可以很方便地将JBOSS和Tomcat集成在一起使用。另外，JBOSS还有配置简单、应用热发布（不用停止服务器及应用的情况下发布或升级应用）等优点。
 
五．JavaEE的应用（一）
 


五．JavaEE的应用（二）

使用JavaEE开发企业应用要注意的问题：
       结合本企业的实际情况选用最适当的技术，需要终合考虑企业规模、业务特征、应用能力、预算费用、性能、开发周期、管理成本、维护成本等各种因素，还需要有一定的前瞻性。
